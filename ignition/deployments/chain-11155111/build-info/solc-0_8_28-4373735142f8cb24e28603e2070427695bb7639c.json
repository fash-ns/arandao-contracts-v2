{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-4373735142f8cb24e28603e2070427695bb7639c",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/orderBook/OrderBook.sol": "project/contracts/orderBook/OrderBook.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/access/Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC1363.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1363.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC165.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC20.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC1155/IERC1155.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC-1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[ERC].\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the zero address.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {IERC1155Receiver-onERC1155Received} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {IERC1155Receiver-onERC1155BatchReceived} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits either a {TransferSingle} or a {TransferBatch} event, depending on the length of the array arguments.\n     *\n     * Requirements:\n     *\n     * - `ids` and `values` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external;\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC1155/IERC1155Receiver.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface that must be implemented by smart contracts in order to receive\n * ERC-1155 token transfers.\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC-1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC-1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC1155/utils/ERC1155Holder.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC1155/utils/ERC1155Holder.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165, ERC165} from \"../../../utils/introspection/ERC165.sol\";\nimport {IERC1155Receiver} from \"../IERC1155Receiver.sol\";\n\n/**\n * @dev Simple implementation of `IERC1155Receiver` that will allow a contract to hold ERC-1155 tokens.\n *\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\n * stuck.\n */\nabstract contract ERC1155Holder is ERC165, IERC1155Receiver {\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/utils/SafeERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC721/IERC721.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC721/IERC721.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC-721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC-721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC-721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC721/IERC721Receiver.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity >=0.5.0;\n\n/**\n * @title ERC-721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC-721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\n     * reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC721/utils/ERC721Holder.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/utils/ERC721Holder.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721Receiver} from \"../IERC721Receiver.sol\";\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or\n * {IERC721-setApprovalForAll}.\n */\nabstract contract ERC721Holder is IERC721Receiver {\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(address, address, uint256, bytes memory) public virtual returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/introspection/ERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/introspection/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/ReentrancyGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
      },
      "project/contracts/orderBook/OrderBook.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {OrderBookStorage} from \"./OrderBookCore/BookStorage.sol\";\nimport {ShareManager} from \"./OrderBookCore/ShareManager.sol\";\nimport {ListingManager} from \"./OrderBookCore/ListingManager.sol\";\nimport {OfferManager} from \"./OrderBookCore/OfferManager.sol\";\nimport {Helper} from \"./OrderBookCore/Helper.sol\";\nimport {ERC721Holder} from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport {ERC1155Holder} from \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\n\n/**\n * @title NFT OrderBook (ERC721 + ERC1155)\n * @author Sajad-Salehi\n * @notice Modular orderbook contract that supports:\n *  - Buyers creating offers (escrowed in USDT) for any whitelisted collection/token\n *  - Sellers accepting offers (transfer NFT -> buyer, pay seller in USDT)\n *  - Sellers listing NFTs for sale (buyers pay USDT and receive NFT)\n *  - Whitelisted collections only (with designated standard: ERC721 or ERC1155)\n *  - Payments only in a configured ERC20 (USDT) token\n *\n * Design notes:\n *  - Buyers' offers are escrowed on createOffer (USDT transferred to contract).\n *  - Listings are off-chain/approval-based: seller must approve this contract to transfer\n *    their NFT when a buyer calls buyListing. This avoids locking NFTs in contract.\n *  - ERC1155 supports multi-quantity listings/offers; ERC721 amount is always 1.\n *  - Platform fee (bps) is configurable by owner; fee is deducted on successful sale\n *    and kept in contract until owner withdraws.\n */\ncontract NFTOrderBook is\n  Ownable,\n  ReentrancyGuard,\n  ERC721Holder,\n  ERC1155Holder,\n  OrderBookStorage,\n  ShareManager,\n  ListingManager,\n  OfferManager,\n  Helper\n{\n  /// @notice Ensures that the collection is whitelisted and quantity is valid\n  modifier onlyValidCollection(address collection, uint256 quantity) {\n    _checkCollection(collection, quantity);\n    _;\n  }\n\n  /// @notice Constructor to initialize the NFTOrderBook contract\n  constructor(\n    address initialOwner,\n    address _usdtToken,\n    address _bvRecipient,\n    address _feeRecipient,\n    uint256 _denom,\n    uint256 _sellerNum,\n    uint256 _bvNum,\n    uint256 _minimumPrice\n  )\n    Ownable(initialOwner)\n    OrderBookStorage(\n      _usdtToken,\n      _bvRecipient,\n      _feeRecipient,\n      _denom,\n      _sellerNum,\n      _bvNum,\n      _minimumPrice\n    )\n  {}\n\n  /// @notice List an NFT for sale\n  /// @param collection NFT contract address\n  /// @param tokenId Token ID to list\n  /// @param sellerPrice Price requested by the seller\n  /// @param quantity Quantity of NFTs (1 for ERC721)\n  /// @dev Transfers NFT from seller to contract (escrow) and emits ListingCreated\n  function listTokenForSale(\n    address collection,\n    uint256 tokenId,\n    uint256 sellerPrice,\n    uint256 quantity\n  ) external onlyValidCollection(collection, quantity) nonReentrant {\n    require(sellerPrice >= _minPrice, \"price must be >= minimum amount\");\n\n    (, , uint256 buyerPrice) = _computeFromSeller(sellerPrice);\n    address seller = msg.sender;\n\n    _handleNftTransferFrom(\n      seller,\n      address(this),\n      collection,\n      tokenId,\n      quantity\n    );\n    _createListing(\n      seller,\n      collection,\n      tokenId,\n      sellerPrice,\n      buyerPrice,\n      quantity\n    );\n  }\n\n  /// @notice Cancel an active listing and return NFT to seller\n  /// @param listingId ID of the listing to cancel\n  function cancelListForSale(uint256 listingId) external nonReentrant {\n    Listing memory listing = listings[listingId];\n    address caller = msg.sender;\n\n    require(listing.active, \"listing not active\");\n    require(listing.seller == caller, \"not listing owner\");\n\n    _cancelListing(caller, listingId);\n    _handleNftTransferFrom(\n      address(this),\n      listing.seller,\n      listing.collection,\n      listing.tokenId,\n      listing.quantity\n    );\n  }\n\n  /// @notice Buy an NFT from an active listing\n  /// @param listingId ID of the listing\n  /// @param quantity Number of NFTs to buy\n  /// @dev Transfers USDT from buyer, distributes shares, and transfers NFT to buyer\n  function buyListing(\n    uint256 listingId,\n    uint256 quantity,\n    address parent\n  ) external nonReentrant {\n    require(parent != address(0), \"Invalid parent address\");\n\n    Listing memory listing = listings[listingId];\n    require(quantity > 0 && quantity <= listing.quantity, \"invalid quantity\");\n\n    address buyer = msg.sender;\n    uint256 tbuyAmount = listing.buyerPrice * quantity;\n    require(\n      usdt.allowance(buyer, address(this)) >= tbuyAmount,\n      \"insufficient allowance\"\n    );\n\n    require(listing.active, \"listing not active\");\n    require(listing.seller != buyer, \"cannot buy own listing\");\n\n    // Mark listing as inactive\n    _buyListing(listingId, buyer, quantity);\n\n    // Transfer USDT from buyer to Contract (**should change to entry point**)\n    _handleTokenTransferFrom(buyer, address(this), tbuyAmount);\n\n    // Distribute USDT to BV and fee recipient\n    // Todo *** pass shares and associated addresses to entry point for distribution ***\n    // Todo pass parent address from input to entrypoint contract\n    (\n      uint256 sellerAmount,\n      uint256 bvAmount,\n      uint256 creatorAmount\n    ) = _computeShares(listing.buyerPrice);\n    _handleTokenTransfer(listing.seller, sellerAmount * quantity);\n    _handleTokenTransfer(bvRecipient, bvAmount * quantity);\n    _handleTokenTransfer(feeRecipient, creatorAmount * quantity);\n\n    // Transfer NFT from contract to buyer\n    _handleNftTransferFrom(\n      address(this),\n      buyer,\n      listing.collection,\n      listing.tokenId,\n      quantity\n    );\n  }\n\n  /// @notice Place an offer for an NFT\n  /// @param collection NFT contract address\n  /// @param tokenId Token ID to buy\n  /// @param quantity Quantity requested\n  /// @param buyerPrice Price per token buyer is willing to pay (includes fees)\n  /// @dev Escrows USDT on offer creation\n  function placeOffer(\n    address collection,\n    uint256 tokenId,\n    uint256 quantity,\n    uint256 buyerPrice,\n    address parent\n  ) external onlyValidCollection(collection, quantity) nonReentrant {\n    require(buyerPrice > _minPrice, \"price must be >= minimum amount\");\n\n    address buyer = msg.sender;\n\n    // Compute total cost and transfer USDT from buyer to contract\n    uint256 totalCost = buyerPrice * quantity;\n    _handleTokenTransferFrom(buyer, address(this), totalCost);\n\n    (, , uint256 sellerPrice) = _computeShares(buyerPrice);\n    _createOffer(\n      buyer,\n      parent,\n      collection,\n      tokenId,\n      quantity,\n      buyerPrice,\n      sellerPrice\n    );\n  }\n\n  /// @notice Cancel an active offer and refund the buyer\n  /// @param offerId ID of the offer to cancel\n  function cancelOffer(uint256 offerId) external nonReentrant {\n    Offer memory offer = offers[offerId];\n    address caller = msg.sender;\n\n    require(offer.active, \"offer not active\");\n    require(offer.buyer == caller, \"not offer owner\");\n\n    // Mark offer as inactive\n    _cancelOffer(offerId, caller);\n\n    // Refund USDT to buyer\n    uint256 refundAmount = offer.buyerPrice * offer.quantity;\n    _handleTokenTransfer(offer.buyer, refundAmount);\n  }\n\n  /// @notice Accept an active offer as a seller\n  /// @param offerId ID of the offer\n  /// @param quantity Quantity of NFTs to sell\n  /// @dev Transfers NFT to buyer and distributes USDT shares\n  function acceptOffer(\n    uint256 offerId,\n    uint256 quantity\n  ) external nonReentrant {\n    Offer memory offer = offers[offerId];\n    require(quantity > 0 && quantity <= offer.quantity, \"invalid quantity\");\n\n    address seller = msg.sender;\n    require(offer.active, \"offer not active\");\n    require(offer.buyer != seller, \"cannot accept own offer\");\n\n    // Transfer NFT from seller to buyer\n    _handleNftTransferFrom(\n      seller,\n      offer.buyer,\n      offer.collection,\n      offer.tokenId,\n      quantity\n    );\n\n    // Mark offer as inactive\n    _acceptOffer(offerId, seller, quantity);\n\n    // Distribute USDT to seller, BV and fee recipient\n    // Todo *** pass shares and associated addresses to entry point for distribution ***\n    // Todo pass the parent address to entrypoint (parents[buyer])\n    (\n      uint256 bvAmount,\n      uint256 creatorAmount,\n      uint256 sellerAmount\n    ) = _computeShares(offer.buyerPrice);\n    _handleTokenTransfer(bvRecipient, bvAmount * quantity);\n    _handleTokenTransfer(feeRecipient, creatorAmount * quantity);\n    _handleTokenTransfer(seller, sellerAmount * quantity);\n  }\n\n  function registerCollection(\n    address collection,\n    uint8 typeNum\n  ) external onlyOwner {\n    collections[collection] = CollectionInfo(TokenType(typeNum), true);\n  }\n\n  function removeCollection(address collection) external onlyOwner {\n    collections[collection].exists = false;\n  }\n\n  /// @notice Transfers contract ownership to a new address, but only once.\n  /// @dev Uses `ownershipFlag` to ensure ownership can only be transferred a single time.\n  function transferOwnership(address newOwner) public override onlyOwner {\n    if (ownershipFlag == false) {\n      super.transferOwnership(newOwner);\n      ownershipFlag = true;\n    } else {\n      revert(\"Ownership has already been transferred\");\n    }\n  }\n}\n"
      },
      "project/contracts/orderBook/OrderBookCore/BookStorage.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title Abstract Storage for an Order Book Marketplace\n/// @notice Stores all essential state variables and structures for listings and offers of ERC721/ERC1155 tokens\nabstract contract OrderBookStorage {\n  /// @notice ERC20 token used for payments (e.g., USDT stablecoin)\n  IERC20 internal usdt;\n\n  // Fraction constants used for fee distribution (numerator / DENOM)\n  uint256 internal immutable DENOM; // Denominator for fractional calculations (e.g., 167)\n  uint256 internal immutable SELLER_NUM; // Seller's fraction numerator (e.g., 50 / 167)\n  uint256 internal immutable BV_NUM; // BV's fraction numerator (e.g., 100 / 167)\n\n  /// @notice ID for new listings and offers\n  uint256 internal _nextListingId;\n  uint256 internal _nextOfferId;\n\n  // @notice min price\n  uint256 internal _minPrice;\n\n  /// @notice Address receiving BV portion of payments and platform fees\n  address public bvRecipient;\n  address public feeRecipient;\n\n  /// @notice Flag to allow ownership transfer only once.\n  bool public ownershipFlag;\n\n  /// @notice Supported token types in marketplace\n  enum TokenType {\n    ERC721,\n    ERC1155\n  }\n\n  /// @notice Metadata for supported collections\n  struct CollectionInfo {\n    TokenType tokenType;\n    bool exists; // True if the collection is supported\n  }\n\n  /// @notice Represents an NFT listed for sale\n  struct Listing {\n    address seller; // Owner of the NFT\n    address collection; // NFT collection contract address\n    uint256 tokenId; // Token ID of the NFT\n    uint256 quantity; // Number of tokens listed (1 for ERC721)\n    uint256 sellerPrice; // Listing price in USDT\n    uint256 buyerPrice; // Price if bought via \"Buy Now\" option\n    bool active; // True if listing is currently active\n  }\n\n  /// @notice Represents an offer made by a buyer on a listed NFT\n  struct Offer {\n    address buyer; // Buyer address\n    address collection; // NFT collection contract address\n    uint256 tokenId; // Token ID of the NFT\n    uint256 quantity; // Amount buyer wants to purchase\n    uint256 sellerPrice; // Listing price in USDT\n    uint256 buyerPrice; // Price if bought via \"Buy Now\" option\n    bool active; // True if offer is currently active\n  }\n\n  /// @notice Mapping of supported NFT collections\n  mapping(address => CollectionInfo) public collections;\n\n  /// @notice Mapping from listing ID to Listing struct\n  mapping(uint256 => Listing) public listings;\n\n  /// @notice Mapping from offer ID to Offer struct\n  mapping(uint256 => Offer) public offers;\n\n  /// @notice parent addresses\n  mapping(address => address) public parents;\n\n  /// @notice Constructor initializes core parameters and fee distribution numerators\n  constructor(\n    address _usdtToken,\n    address _bvRecipient,\n    address _feeRecipient,\n    uint256 _denom,\n    uint256 _sellerNum,\n    uint256 _bvNum,\n    uint256 _minimumPrice\n  ) {\n    require(_usdtToken != address(0), \"USDT zero\");\n    require(_bvRecipient != address(0), \"bvRecipient zero\");\n    require(_feeRecipient != address(0), \"feeRecipient zero\");\n    require(_denom != 0, \"DENOM zero\");\n\n    usdt = IERC20(_usdtToken);\n    feeRecipient = _feeRecipient;\n    bvRecipient = _bvRecipient;\n\n    DENOM = _denom;\n    SELLER_NUM = _sellerNum;\n    BV_NUM = _bvNum;\n\n    _minPrice = _minimumPrice;\n\n    _nextListingId = 1; // Start listing IDs from 1\n    _nextOfferId = 1; // Start offer IDs from 1\n  }\n}\n"
      },
      "project/contracts/orderBook/OrderBookCore/Helper.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport {OrderBookStorage} from \"./BookStorage.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\n/// @title Helper\n/// @notice Provides internal utility functions for handling NFT and ERC20 token transfers, and collection validation.\n/// @dev Inherits storage from OrderBookStorage\nabstract contract Helper is OrderBookStorage {\n  /// @notice Transfers an NFT from one address to another\n  /// @dev Supports both ERC721 and ERC1155 standards\n  function _handleNftTransferFrom(\n    address from,\n    address to,\n    address collection,\n    uint256 tokenId,\n    uint256 quantity\n  ) internal {\n    TokenType tokenType = collections[collection].tokenType;\n\n    if (tokenType == TokenType.ERC721) {\n      // ERC721 supports only single token transfers\n      IERC721(collection).safeTransferFrom(from, to, tokenId);\n    } else if (tokenType == TokenType.ERC1155) {\n      // ERC1155 supports batch/multiple token transfers\n      IERC1155(collection).safeTransferFrom(from, to, tokenId, quantity, \"\");\n    }\n  }\n\n  /// @notice Transfers ERC20 tokens from a sender to a recipient\n  /// @dev Assumes `usdt` is an ERC20-compatible token stored in OrderBookStorage\n  function _handleTokenTransferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) internal {\n    bool isSuccess = usdt.transferFrom(from, to, amount);\n    require(isSuccess, \"Token transfer failed\");\n  }\n\n  /// @notice Transfers ERC20 tokens from this contract to a recipient\n  function _handleTokenTransfer(address to, uint256 amount) internal {\n    bool isSuccess = usdt.transfer(to, amount);\n    require(isSuccess, \"Token transfer failed\");\n  }\n\n  /// @notice Validates that a collection is whitelisted and that the quantity is valid\n  function _checkCollection(\n    address collection,\n    uint256 quantity\n  ) internal view {\n    CollectionInfo memory info = collections[collection];\n    require(info.exists, \"collection not whitelisted\");\n\n    if (info.tokenType == TokenType.ERC721) {\n      require(quantity == 1, \"ERC721 quantity must be 1\");\n    } else if (info.tokenType == TokenType.ERC1155) {\n      require(quantity > 0, \"ERC1155 quantity must be greater than 0\");\n    }\n  }\n}\n"
      },
      "project/contracts/orderBook/OrderBookCore/ListingManager.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport {OrderBookStorage} from \"./BookStorage.sol\";\n\n/// @title ListingManager\n/// @notice Abstract contract responsible for managing listings in the order book, including creation, cancellation, and purchases.\n/// @dev Inherits storage from OrderBookStorage\nabstract contract ListingManager is OrderBookStorage {\n  /// @notice Emitted when a new listing is created\n  event ListingCreated(\n    uint256 indexed listingId,\n    address indexed seller,\n    address collection,\n    uint256 tokenId,\n    uint256 sellerPrice,\n    uint256 buyerPrice,\n    uint256 quantity\n  );\n\n  /// @notice Emitted when a listing is cancelled\n  event ListingCancelled(uint256 indexed listingId, address indexed seller);\n\n  /// @notice Emitted when a listing is partially or fully purchased\n  event ListingPurchased(\n    uint256 indexed listingId,\n    address indexed seller,\n    address indexed buyer\n  );\n\n  /// @notice Emitted when a listing is fully executed (all quantity sold)\n  event ListingExecuted(uint256 indexed listingId, address indexed buyer);\n\n  /// @notice Internal function to create a new listing\n  /// @dev Automatically assigns a unique listing ID and stores the listing\n  /// @param seller Address of the seller\n  /// @param collection Address of the NFT collection\n  /// @param tokenId Token ID of the NFT\n  /// @param sellerPrice Price the seller wants\n  /// @param buyerPrice Price for instant purchase\n  /// @param quantity Quantity of tokens to list\n  function _createListing(\n    address seller,\n    address collection,\n    uint256 tokenId,\n    uint256 sellerPrice,\n    uint256 buyerPrice,\n    uint256 quantity\n  ) internal {\n    uint256 listingId = _nextListingId++;\n\n    // Store the listing in the contract state\n    listings[listingId] = Listing({\n      seller: seller,\n      collection: collection,\n      tokenId: tokenId,\n      quantity: quantity,\n      sellerPrice: sellerPrice,\n      buyerPrice: buyerPrice,\n      active: true\n    });\n\n    emit ListingCreated(\n      listingId,\n      seller,\n      collection,\n      tokenId,\n      sellerPrice,\n      buyerPrice,\n      quantity\n    );\n  }\n\n  /// @notice Internal function to cancel an existing listing\n  /// @dev Marks the listing as inactive\n  function _cancelListing(address seller, uint256 listingId) internal {\n    listings[listingId].active = false;\n    emit ListingCancelled(listingId, seller);\n  }\n\n  /// @notice Internal function to purchase a listing\n  /// @dev Updates quantity and emits relevant events; if fully purchased, marks the listing inactive\n  function _buyListing(\n    uint256 listingId,\n    address buyer,\n    uint256 quantity\n  ) internal {\n    Listing storage listing = listings[listingId];\n\n    // Reduce the available quantity\n    listing.quantity -= quantity;\n\n    // If all tokens are purchased, deactivate listing and emit executed event\n    if (listing.quantity == 0) {\n      listing.active = false;\n      emit ListingExecuted(listingId, buyer);\n    }\n\n    emit ListingPurchased(listingId, listing.seller, buyer);\n  }\n}\n"
      },
      "project/contracts/orderBook/OrderBookCore/OfferManager.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport {OrderBookStorage} from \"./BookStorage.sol\";\n\n/// @title OfferManager\n/// @notice Manages offers/Orders in the OrderBook, including creation, cancellation, and acceptance.\nabstract contract OfferManager is OrderBookStorage {\n  /// @notice Emitted when a new offer is created\n  event OfferCreated(\n    uint256 indexed id,\n    address indexed buyer,\n    address collection,\n    uint256 tokenId,\n    uint256 quantity,\n    uint256 price\n  );\n\n  /// @notice Emitted when an offer is cancelled\n  event OfferCancelled(uint256 indexed id, address indexed buyer);\n\n  /// @notice Emitted when an offer is accepted (partially or fully)\n  event OfferAccepted(\n    uint256 indexed id,\n    address indexed buyer,\n    address seller,\n    uint256 quantity\n  );\n\n  /// @notice Emitted when an offer is fully executed (all quantity accepted)\n  event OfferExecuted(uint256 indexed id, address indexed buyer);\n\n  /// @notice Internal function to create a new offer\n  function _createOffer(\n    address buyer,\n    address parent,\n    address collection,\n    uint256 tokenId,\n    uint256 quantity,\n    uint256 buyerPrice,\n    uint256 sellerPrice\n  ) internal {\n    // set the buyer's parent if not exist\n    if (parents[buyer] == address(0)) {\n      parents[buyer] = parent;\n    }\n\n    uint256 offerId = _nextOfferId++;\n    offers[offerId] = Offer(\n      buyer,\n      collection,\n      tokenId,\n      quantity,\n      sellerPrice,\n      buyerPrice,\n      true\n    );\n    emit OfferCreated(\n      offerId,\n      buyer,\n      collection,\n      tokenId,\n      quantity,\n      buyerPrice\n    );\n  }\n\n  /// @notice Internal function to cancel an existing offer\n  function _cancelOffer(uint256 offerId, address caller) internal {\n    offers[offerId].active = false;\n    emit OfferCancelled(offerId, caller);\n  }\n\n  /// @notice Internal function to accept an offer\n  /// @dev Updates quantity, and deactivates offer if fully executed\n  function _acceptOffer(\n    uint256 offerId,\n    address seller,\n    uint256 quantity\n  ) internal {\n    Offer storage offer = offers[offerId];\n    offer.quantity -= quantity;\n    address buyer = offer.buyer;\n\n    // Deactivate offer if fully executed\n    if (offer.quantity == 0) {\n      offer.active = false;\n      emit OfferExecuted(offerId, buyer);\n    }\n\n    emit OfferAccepted(offerId, buyer, seller, quantity);\n  }\n}\n"
      },
      "project/contracts/orderBook/OrderBookCore/ShareManager.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport {OrderBookStorage} from \"./BookStorage.sol\";\n\n/// @title ShareManager\n/// @notice Handles the computation of revenue shares for sellers, platform (bv), and creators.\n/// @dev Uses fixed ratios and integer arithmetic to ensure the sum of shares equals the total amount\nabstract contract ShareManager is OrderBookStorage {\n  /**\n   * @dev Payment split logic (from total `total`):\n   *\n   * Current rules:\n   *   bv = 2  seller\n   *   creator = 17% of bv\n   *\n   * Derivation:\n   *  T = seller + bv + creator = S + 2S + 0.34S = 3.34S\n   *   seller = 50/167  T\n   *   bv     = 100/167  T\n   *   creator = 17/167  T\n   *\n   * Solidity constants:\n   *  DENOM = 167, SELLER_NUM = 50, BV_NUM = 100\n   *  Creator share = DENOM - SELLER_NUM - BV_NUM = 17\n   *\n   * To update ratios:\n   *  1. Set new bv_ratio (bv/seller) and creator_ratio (creator/bv)\n   *  2. Compute seller = T / (1 + bv_ratio + bv_ratio * creator_ratio)\n   *  3. Compute bv = seller  bv_ratio\n   *  4. Compute creator = T - seller - bv\n   *  5. Convert to integer numerators with a common denominator (DENOM)\n   */\n\n  /// @notice Computes individual shares (seller, bv, creator) from a total amount\n  function _computeShares(\n    uint256 total\n  )\n    internal\n    view\n    returns (uint256 sellerAmt, uint256 bvAmt, uint256 creatorAmt)\n  {\n    sellerAmt = (total * SELLER_NUM) / DENOM;\n    bvAmt = (total * BV_NUM) / DENOM;\n    creatorAmt = total - sellerAmt - bvAmt; // Remainder ensures exact total\n  }\n\n  /// @notice Computes the bv, creator, and total amounts given a seller amount\n  function _computeFromSeller(\n    uint256 seller\n  ) internal view returns (uint256 bvAmt, uint256 creatorAmt, uint256 total) {\n    bvAmt = (seller * BV_NUM) / SELLER_NUM; // bv = seller  BV_NUM / SELLER_NUM\n    creatorAmt = (seller * (DENOM - SELLER_NUM - BV_NUM)) / SELLER_NUM; // creator = seller  17 / 50\n    total = seller + bvAmt + creatorAmt; // total = seller  DENOM / SELLER_NUM\n  }\n}\n"
      }
    }
  }
}