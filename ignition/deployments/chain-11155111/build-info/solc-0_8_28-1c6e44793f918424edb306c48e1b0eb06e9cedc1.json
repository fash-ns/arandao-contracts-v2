{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-1c6e44793f918424edb306c48e1b0eb06e9cedc1",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/dex/Dex.sol": "project/contracts/dex/Dex.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/access/Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC1363.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1363.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC165.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC20.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/utils/SafeERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/introspection/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/ReentrancyGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
      },
      "project/contracts/dex/Dex.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {DexStorage} from \"./DexCore/DexStorage.sol\";\nimport {DexHelper} from \"./DexCore/DexHelper.sol\";\nimport {DexErrors} from \"./DexCore/DexErrors.sol\";\n\n/**\n * @title Dex\n * @notice The main contract for the ERC20 Order Book, providing public trading interfaces.\n * @dev Implements the core logic by leveraging inherited storage and helper functionalities.\n */\ncontract Dex is Ownable, ReentrancyGuard, DexStorage, DexHelper {\n  /**\n   * @notice Initializes the contract with tokens, fee recipient, and fee tiers.\n   * @param initialOwner The address of the contract owner.\n   * @param _dnmToken The address of the base token (e.g., DNM).\n   * @param _daiToken The address of the quote token (e.g., DAI).\n   * @param _feeReceiver The address designated to receive trading fees.\n   * @param _vault The address of the vault for getting dnm price range\n   * @param _feeTiers The configuration array for tiered fee structure.\n   */\n  constructor(\n    address initialOwner,\n    address _dnmToken,\n    address _daiToken,\n    address _feeReceiver,\n    address _vault,\n    FeeTier[] memory _feeTiers\n  )\n    Ownable(initialOwner)\n    DexStorage(_dnmToken, _daiToken, _feeReceiver, _vault, _feeTiers)\n  {}\n\n  /**\n   * @notice Places a new buy order (Maker is selling DAI, buying DNM).\n   * @dev Requires the maker to have approved the contract to spend the DAI equivalent of (amount * price).\n   * @param amount The amount of DNM (base token) to buy.\n   * @param price The price of DNM in DAI (quote token) per DNM (scaled by 1e18).\n   */\n  function placeBuyOrder(\n    uint256 amount,\n    uint256 price\n  ) external onlyValidPrice(price) nonReentrant {\n    if (amount == 0 || price == 0) revert DexErrors.InvalidAmounts();\n\n    // Maker must transfer DAI to contract as collateral for the trade\n    uint256 daiCollateral = (amount * price) / (10 ** 18);\n    _handleTransferFrom(daiToken, msg.sender, address(this), daiCollateral);\n\n    _createOrder(msg.sender, amount, price, false); // false for Buy Order\n  }\n\n  /**\n   * @notice Places a new sell order (Maker is selling DNM, buying DAI).\n   * @dev Requires the maker to have approved the contract to spend the DNM `amount`.\n   * @param amount The amount of DNM (base token) to sell.\n   * @param price The price of DNM in DAI (quote token) per DNM (scaled by 1e18).\n   */\n  function placeSellOrder(\n    uint256 amount,\n    uint256 price\n  ) external onlyValidPrice(price) nonReentrant {\n    if (amount == 0 || price == 0) revert DexErrors.InvalidAmounts();\n\n    // Maker must transfer DNM to contract as collateral for the trade\n    _handleTransferFrom(dnmToken, msg.sender, address(this), amount);\n\n    _createOrder(msg.sender, amount, price, true); // true for Sell Order\n  }\n\n  /**\n   * @notice Cancels an existing active order. Only the maker can call this.\n   * @dev The calling contract should handle the refund of collateral.\n   * @param orderId The ID of the order to cancel.\n   */\n  function cancelOrder(\n    uint256 orderId\n  ) external onlyActiveOrder(orderId) nonReentrant {\n    // Validation: Only the maker can cancel their own order\n    if (orders[orderId].maker != msg.sender) {\n      revert DexErrors.Unauthorized();\n    }\n\n    // The helper handles the status update and event emission\n    _cancelOrder(msg.sender, orderId);\n\n    // Refund the maker their collateral based on order type\n    _refundMaker(orderId);\n  }\n\n  /**\n   * @notice Executes a full trade against an existing active order (Taker).\n   * @param orderId The ID of the order to execute.\n   */\n  function executeOrder(\n    uint256 orderId\n  ) external onlyActiveOrder(orderId) nonReentrant {\n    // The `_executeTrade` function handles all token transfers (collateral from contract, funds from taker, fees).\n    _executeOrder(orderId, msg.sender);\n  }\n\n  /**\n   * @notice Retrieves the details of a specific order.\n   * @param orderId The ID of the order to retrieve.\n   * @return Order struct containing all order details.\n   */\n  function getOrder(uint256 orderId) external view returns (Order memory) {\n    // Simple getter function. Does not require a helper.\n    if (orderId == 0 || orderId >= nextOrderId) {\n      revert DexErrors.OrderNotFound();\n    }\n    return orders[orderId];\n  }\n\n  /**\n   * @notice Retrieves all order IDs associated with a specific user.\n   * @param user The address of the user.\n   * @return An array of Order structs associated with the user.\n   */\n  function getUserOrders(address user) external view returns (Order[] memory) {\n    uint256[] storage userOrderIds = makerOrders[user];\n    Order[] memory userOrders = new Order[](userOrderIds.length);\n\n    for (uint256 i = 0; i < userOrderIds.length; i++) {\n      userOrders[i] = orders[userOrderIds[i]];\n    }\n    return userOrders;\n  }\n}\n"
      },
      "project/contracts/dex/DexCore/DexErrors.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\n/**\n * @title DexErrors\n * @dev Custom errors for gas-efficient error handling.\n */\nlibrary DexErrors {\n  error ZeroAddress();\n  error SameTokens();\n  error FeeTooHigh();\n  error Unauthorized();\n  error InvalidTierConfiguration();\n  error InvalidAmounts();\n  error OrderNotActive();\n  error OrderNotFound();\n  error InvalidFillAmount();\n  error FillExceedsRemaining();\n  error CannotFillOwnOrder();\n  error NotOrderMaker();\n  error InvalidOrder(uint256 id);\n  error AmountMustBePositive();\n  error PriceMustBePositive();\n  error PriceOutOfRange();\n}\n"
      },
      "project/contracts/dex/DexCore/DexHelper.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport {DexStorage} from \"./DexStorage.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {DexErrors} from \"./DexErrors.sol\";\n\n/**\n * @title DexHelper\n * @notice Provides internal helper functions for core DEX operations, including token handling,\n * order creation, cancellation, execution, and fee calculation.\n * @dev This abstract contract assumes a full-fill execution model, meaning any accepted order\n * is completed in its entirety. It inherits required storage fields from DexStorage.\n */\nabstract contract DexHelper is DexStorage {\n  using SafeERC20 for IERC20;\n\n  event OrderPlaced(\n    uint256 orderId,\n    address maker,\n    bool isSell,\n    uint256 amountDNM,\n    uint256 price\n  );\n  event OrderCanceled(uint256 orderId, address maker);\n  event OrderFilled(\n    uint256 orderId,\n    address maker,\n    address taker,\n    uint256 dnmTraded,\n    uint256 daiTraded,\n    uint256 dnmFee,\n    uint256 daiFee\n  );\n  event FeesWithdrawn(address feeReceiver, address token, uint256 amount);\n\n  modifier onlyActiveOrder(uint256 orderId) {\n    _onlyActiveOrder(orderId);\n    _;\n  }\n\n  modifier onlyValidPrice(uint256 price) {\n    _onlyValidPrice(price);\n    _;\n  }\n\n  /**\n   * @notice Validates that the provided price is within the acceptable range.\n   * @dev This example assumes a simplistic check against a vault price. Adjust logic as needed.\n   */\n  function _onlyValidPrice(uint256 price) internal view {\n    uint256 vaultPrice = vault.getPrice();\n    if (price < vaultPrice) revert DexErrors.PriceOutOfRange();\n  }\n\n  /**\n   * @notice Validates that the specified order is active.\n   * @dev Reverts if the order is not in Active status.\n   */\n  function _onlyActiveOrder(uint256 orderId) internal view {\n    if (orders[orderId].status != Status.Active) {\n      revert DexErrors.OrderNotActive();\n    }\n  }\n\n  /**\n   * @notice Safely transfers tokens from a specified address to another.\n   * @dev Prevents execution if the amount is zero.\n   */\n  function _handleTransferFrom(\n    address token,\n    address from,\n    address to,\n    uint256 amount\n  ) internal {\n    IERC20(token).safeTransferFrom(from, to, amount);\n  }\n\n  /**\n   * @notice Safely transfers tokens from the contract to a recipient.\n   * @dev Prevents execution if the amount is zero.\n   */\n  function _handleTransfer(address token, address to, uint256 amount) internal {\n    IERC20(token).safeTransfer(to, amount);\n  }\n\n  /**\n   * @notice Creates a new active order and increments the global order ID counter.\n   */\n  function _createOrder(\n    address user,\n    uint256 amount,\n    uint256 price,\n    bool isSell\n  ) internal {\n    uint256 orderId = nextOrderId++;\n\n    orders[orderId] = Order({\n      id: orderId,\n      maker: user,\n      taker: address(0),\n      isSell: isSell,\n      amount: amount,\n      price: price,\n      status: Status.Active\n    });\n\n    makerOrders[user].push(orderId);\n    emit OrderPlaced(orderId, user, isSell, amount, price);\n  }\n\n  /**\n   * @notice Sets the status of an existing order to Canceled.\n   * @dev The calling contract is responsible for any necessary refund logic.\n   */\n  function _cancelOrder(address user, uint256 orderId) internal {\n    orders[orderId].status = Status.Canceled;\n    emit OrderCanceled(orderId, user);\n  }\n\n  /**\n   * @notice Executes a full trade against an active order, handling all token transfers and fees.\n   * @dev Assumes full fulfillment. Updates order status to Executed and amount to 0.\n   */\n  function _executeOrder(uint256 orderId, address taker) internal {\n    Order storage order = orders[orderId];\n\n    _onlyValidPrice(order.price);\n    if (orders[orderId].maker == msg.sender)\n      revert DexErrors.CannotFillOwnOrder();\n\n    // Update order state\n    order.status = Status.Executed;\n    order.taker = taker;\n\n    uint256 dnmTraded = order.amount;\n    uint256 daiTraded = (dnmTraded * order.price) / (10 ** 18);\n\n    uint16 feeBps = _getFeeRate(dnmTraded);\n\n    uint256 dnmFee = (dnmTraded * feeBps) / 10000;\n    uint256 daiFee = (daiTraded * feeBps) / 10000;\n\n    address maker = order.maker;\n\n    if (order.isSell) {\n      // Maker is selling DNM, Taker is buying DNM (paying DAI).\n\n      // 1. Taker transfers DAI to the contract\n      _handleTransferFrom(daiToken, taker, address(this), daiTraded);\n\n      // 2. Distribute net DAI to Maker and DAI fees to feeReceiver\n      _handleTransfer(daiToken, maker, daiTraded - daiFee);\n      _handleTransfer(daiToken, feeReceiver, daiFee);\n\n      // 3. Distribute net DNM to Taker and DNM fees to feeReceiver\n      _handleTransfer(dnmToken, taker, dnmTraded - dnmFee);\n      _handleTransfer(dnmToken, feeReceiver, dnmFee);\n    } else {\n      // Maker is buying DNM, Taker is selling DNM (receiving DAI).\n\n      // 1. Taker transfers DNM to the contract\n      _handleTransferFrom(dnmToken, taker, address(this), dnmTraded);\n\n      // 2. Distribute net DNM to Maker and DNM fees to feeReceiver\n      _handleTransfer(dnmToken, maker, dnmTraded - dnmFee);\n      _handleTransfer(dnmToken, feeReceiver, dnmFee);\n\n      // 3. Distribute net DAI to Taker and DAI fees to feeReceiver\n      _handleTransfer(daiToken, taker, daiTraded - daiFee);\n      _handleTransfer(daiToken, feeReceiver, daiFee);\n    }\n\n    emit OrderFilled(\n      orderId,\n      maker,\n      taker,\n      dnmTraded,\n      daiTraded,\n      dnmFee,\n      daiFee\n    );\n  }\n\n  /**\n   * @notice Refunds the maker of a canceled order their collateral.\n   * @dev The calling contract should ensure this is only called for canceled orders.\n   */\n  function _refundMaker(uint256 orderId) internal {\n    Order storage order = orders[orderId];\n    uint256 refundAmount = order.amount;\n\n    if (order.isSell) {\n      _handleTransfer(dnmToken, msg.sender, refundAmount);\n    } else {\n      // Refund DAI collateral\n      uint256 daiToRefund = (refundAmount * order.price) / (10 ** 18);\n      _handleTransfer(daiToken, msg.sender, daiToRefund);\n    }\n  }\n\n  /**\n   * @notice Determines the applicable fee rate based on the DNM trade volume.\n   * @dev Assumes the `feeTiers` array is correctly sorted by `volumeFloor` in ascending order.\n   */\n  function _getFeeRate(\n    uint256 dnmAmount\n  ) internal view returns (uint16 feeBps) {\n    uint16 applicableFeeBps = feeTiers[0].feeBps;\n\n    for (uint256 i = 0; i < feeTiers.length; i++) {\n      if (dnmAmount >= feeTiers[i].volumeFloor) {\n        applicableFeeBps = feeTiers[i].feeBps;\n      } else {\n        // Optimization: break since array is sorted\n        break;\n      }\n    }\n    return applicableFeeBps;\n  }\n}\n"
      },
      "project/contracts/dex/DexCore/DexStorage.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport {DexErrors} from \"./DexErrors.sol\";\nimport {IMultiAssetVault} from \"../interfaces/IMultiAssetVault.sol\";\n\n/**\n * @title DexStorage\n * @dev This abstract contract defines the persistent state and data structures for the OrderBook.\n */\nabstract contract DexStorage {\n  /**\n   * @dev Defines the lifecycle status of an order.\n   */\n  enum Status {\n    NotActive, // Initial state / deleted placeholder\n    Active, // Order is live and partially or fully fillable\n    Canceled, // Order was canceled by the maker\n    Executed // Order was fully filled\n  }\n\n  /**\n   * @dev Defines a fee tier boundary and its corresponding fee rate.\n   * @param volumeFloor The minimum initial DNM amount (scaled by 1e18) to qualify for this tier.\n   * @param feeBps The fee percentage (in basis points, e.g., 5 for 0.05%) for this tier.\n   */\n  struct FeeTier {\n    uint256 volumeFloor; // Minimum DNM amount (scaled 1e18)\n    uint16 feeBps; // Fee in basis points (max 9999)\n  }\n\n  /**\n   * @dev Represents a limit order placed in the book.\n   * @param id Unique identifier.\n   * @param maker The address that placed the order.\n   * @param isSell True for Sell DNM, False for Buy DNM.\n   * @param amount full amount of DNM to trade.\n   * @param price Price: DAI per 1 DNM (multiplied by 1e18 for precision).\n   * @param status Current status in the order lifecycle.\n   */\n  struct Order {\n    uint256 id;\n    address maker;\n    address taker;\n    bool isSell;\n    uint256 amount;\n    uint256 price;\n    Status status;\n  }\n\n  // --- State Variables ---\n\n  /// @notice The ERC20 token being traded (e.g., DNM).\n  address public immutable dnmToken;\n  /// @notice The ERC20 token used for payment (e.g., DAI).\n  address public immutable daiToken;\n  /// @notice The address that receives the trading fees.\n  address public immutable feeReceiver;\n\n  /// @notice The vault contract for secure token transfers.\n  IMultiAssetVault internal immutable vault;\n\n  /// @notice Ordered list of fee tiers. Must be sorted by volumeFloor in ascending order.\n  FeeTier[] public feeTiers;\n\n  /// @notice Unique identifier for the next new order.\n  uint256 public nextOrderId;\n\n  /// @notice Mapping from order ID to the order details.\n  mapping(uint256 => Order) public orders;\n\n  /// @notice Mapping for quick lookup of order IDs by maker.\n  mapping(address => uint256[]) public makerOrders;\n\n  /**\n   * @dev Initializes the immutable token addresses and fee configuration.\n   * @param _dnmToken Address of the DNM ERC20 token.\n   * @param _daiToken Address of the DAI ERC20 token.\n   * @param _feeReceiver Address to send the collected fees.\n   * @param _feeTiers List of initial fee tiers (volumeFloor, feeBps).\n   */\n  constructor(\n    address _dnmToken,\n    address _daiToken,\n    address _feeReceiver,\n    address _vault,\n    FeeTier[] memory _feeTiers\n  ) {\n    if (\n      _dnmToken == address(0) ||\n      _daiToken == address(0) ||\n      _feeReceiver == address(0)\n    ) {\n      revert DexErrors.ZeroAddress();\n    }\n    if (_dnmToken == _daiToken) {\n      revert DexErrors.SameTokens();\n    }\n\n    // --- Initialize Immutable State Variables ---\n    dnmToken = _dnmToken;\n    daiToken = _daiToken;\n    feeReceiver = _feeReceiver;\n    vault = IMultiAssetVault(_vault);\n\n    // --- Fee Tier Validation and Storage Assignment ---\n    if (_feeTiers.length == 0) {\n      revert DexErrors.InvalidTierConfiguration();\n    }\n\n    // Validate structure (ascending volumeFloor and max fee)\n    for (uint256 i = 0; i < _feeTiers.length; i++) {\n      FeeTier memory currentTier = _feeTiers[i];\n\n      // Check max fee rate (10000 BPS = 100%)\n      if (currentTier.feeBps >= 10000) {\n        revert DexErrors.FeeTooHigh();\n      }\n\n      if (i > 0) {\n        if (currentTier.volumeFloor <= _feeTiers[i - 1].volumeFloor) {\n          revert DexErrors.InvalidTierConfiguration();\n        }\n      }\n\n      feeTiers.push(currentTier);\n    }\n\n    nextOrderId = 1;\n  }\n}\n"
      },
      "project/contracts/dex/interfaces/IMultiAssetVault.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\ninterface IMultiAssetVault {\n  function deposit(uint256 amountToDeposit) external;\n  function getPrice() external view returns (uint256);\n  function withdrawDai(uint256 amount) external;\n}\n"
      }
    }
  }
}