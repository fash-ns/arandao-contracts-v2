{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-a57c47b55de9b36f67df16b870910b60294bce3a",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/core/Core.sol": "project/contracts/core/Core.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/ReentrancyGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
      },
      "project/contracts/core/BokkyPooBahsDateTimeLibrary.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\n// ----------------------------------------------------------------------------\n// BokkyPooBah's DateTime Library v1.01\n//\n// A gas-efficient Solidity date and time library\n//\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\n//\n// Tested date range 1970/01/01 to 2345/12/31\n//\n// Conventions:\n// Unit      | Range         | Notes\n// :-------- |:-------------:|:-----\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\n// year      | 1970 ... 2345 |\n// month     | 1 ... 12      |\n// day       | 1 ... 31      |\n// hour      | 0 ... 23      |\n// minute    | 0 ... 59      |\n// second    | 0 ... 59      |\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\n//\n//\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\n// ----------------------------------------------------------------------------\n\nlibrary BokkyPooBahsDateTimeLibrary {\n  uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n  uint constant SECONDS_PER_HOUR = 60 * 60;\n  uint constant SECONDS_PER_MINUTE = 60;\n  int constant OFFSET19700101 = 2440588;\n\n  uint constant DOW_MON = 1;\n  uint constant DOW_TUE = 2;\n  uint constant DOW_WED = 3;\n  uint constant DOW_THU = 4;\n  uint constant DOW_FRI = 5;\n  uint constant DOW_SAT = 6;\n  uint constant DOW_SUN = 7;\n\n  // ------------------------------------------------------------------------\n  // Calculate the number of days from 1970/01/01 to year/month/day using\n  // the date conversion algorithm from\n  //   https://aa.usno.navy.mil/faq/JD_formula.html\n  // and subtracting the offset 2440588 so that 1970/01/01 is day 0\n  //\n  // days = day\n  //      - 32075\n  //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\n  //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\n  //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\n  //      - offset\n  // ------------------------------------------------------------------------\n  function _daysFromDate(\n    uint year,\n    uint month,\n    uint day\n  ) internal pure returns (uint _days) {\n    require(year >= 1970);\n    int _year = int(year);\n    int _month = int(month);\n    int _day = int(day);\n\n    int __days = _day -\n      32075 +\n      (1461 * (_year + 4800 + (_month - 14) / 12)) / 4 +\n      (367 * (_month - 2 - ((_month - 14) / 12) * 12)) / 12 -\n      (3 * ((_year + 4900 + (_month - 14) / 12) / 100)) / 4 -\n      OFFSET19700101;\n\n    _days = uint(__days);\n  }\n\n  // ------------------------------------------------------------------------\n  // Calculate year/month/day from the number of days since 1970/01/01 using\n  // the date conversion algorithm from\n  //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n  // and adding the offset 2440588 so that 1970/01/01 is day 0\n  //\n  // int L = days + 68569 + offset\n  // int N = 4 * L / 146097\n  // L = L - (146097 * N + 3) / 4\n  // year = 4000 * (L + 1) / 1461001\n  // L = L - 1461 * year / 4 + 31\n  // month = 80 * L / 2447\n  // dd = L - 2447 * month / 80\n  // L = month / 11\n  // month = month + 2 - 12 * L\n  // year = 100 * (N - 49) + year + L\n  // ------------------------------------------------------------------------\n  function _daysToDate(\n    uint _days\n  ) internal pure returns (uint year, uint month, uint day) {\n    int __days = int(_days);\n\n    int L = __days + 68569 + OFFSET19700101;\n    int N = (4 * L) / 146097;\n    L = L - (146097 * N + 3) / 4;\n    int _year = (4000 * (L + 1)) / 1461001;\n    L = L - (1461 * _year) / 4 + 31;\n    int _month = (80 * L) / 2447;\n    int _day = L - (2447 * _month) / 80;\n    L = _month / 11;\n    _month = _month + 2 - 12 * L;\n    _year = 100 * (N - 49) + _year + L;\n\n    year = uint(_year);\n    month = uint(_month);\n    day = uint(_day);\n  }\n\n  function timestampFromDate(\n    uint year,\n    uint month,\n    uint day\n  ) internal pure returns (uint timestamp) {\n    timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n  }\n  function timestampFromDateTime(\n    uint year,\n    uint month,\n    uint day,\n    uint hour,\n    uint minute,\n    uint second\n  ) internal pure returns (uint timestamp) {\n    timestamp =\n      _daysFromDate(year, month, day) * SECONDS_PER_DAY +\n      hour * SECONDS_PER_HOUR +\n      minute * SECONDS_PER_MINUTE +\n      second;\n  }\n  function timestampToDate(\n    uint timestamp\n  ) internal pure returns (uint year, uint month, uint day) {\n    (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n  }\n  function timestampToDateTime(\n    uint timestamp\n  )\n    internal\n    pure\n    returns (\n      uint year,\n      uint month,\n      uint day,\n      uint hour,\n      uint minute,\n      uint second\n    )\n  {\n    (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    uint secs = timestamp % SECONDS_PER_DAY;\n    hour = secs / SECONDS_PER_HOUR;\n    secs = secs % SECONDS_PER_HOUR;\n    minute = secs / SECONDS_PER_MINUTE;\n    second = secs % SECONDS_PER_MINUTE;\n  }\n\n  function isValidDate(\n    uint year,\n    uint month,\n    uint day\n  ) internal pure returns (bool valid) {\n    if (year >= 1970 && month > 0 && month <= 12) {\n      uint daysInMonth = _getDaysInMonth(year, month);\n      if (day > 0 && day <= daysInMonth) {\n        valid = true;\n      }\n    }\n  }\n  function isValidDateTime(\n    uint year,\n    uint month,\n    uint day,\n    uint hour,\n    uint minute,\n    uint second\n  ) internal pure returns (bool valid) {\n    if (isValidDate(year, month, day)) {\n      if (hour < 24 && minute < 60 && second < 60) {\n        valid = true;\n      }\n    }\n  }\n  function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n    (uint year, , ) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    leapYear = _isLeapYear(year);\n  }\n  function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n    leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n  }\n  function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n    weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n  }\n  function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n    weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n  }\n  function getDaysInMonth(\n    uint timestamp\n  ) internal pure returns (uint daysInMonth) {\n    (uint year, uint month, ) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    daysInMonth = _getDaysInMonth(year, month);\n  }\n  function _getDaysInMonth(\n    uint year,\n    uint month\n  ) internal pure returns (uint daysInMonth) {\n    if (\n      month == 1 ||\n      month == 3 ||\n      month == 5 ||\n      month == 7 ||\n      month == 8 ||\n      month == 10 ||\n      month == 12\n    ) {\n      daysInMonth = 31;\n    } else if (month != 2) {\n      daysInMonth = 30;\n    } else {\n      daysInMonth = _isLeapYear(year) ? 29 : 28;\n    }\n  }\n  // 1 = Monday, 7 = Sunday\n  function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n    uint _days = timestamp / SECONDS_PER_DAY;\n    dayOfWeek = ((_days + 3) % 7) + 1;\n  }\n\n  function getYear(uint timestamp) internal pure returns (uint year) {\n    (year, , ) = _daysToDate(timestamp / SECONDS_PER_DAY);\n  }\n  function getMonth(uint timestamp) internal pure returns (uint month) {\n    (, month, ) = _daysToDate(timestamp / SECONDS_PER_DAY);\n  }\n  function getDay(uint timestamp) internal pure returns (uint day) {\n    (, , day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n  }\n  function getHour(uint timestamp) internal pure returns (uint hour) {\n    uint secs = timestamp % SECONDS_PER_DAY;\n    hour = secs / SECONDS_PER_HOUR;\n  }\n  function getMinute(uint timestamp) internal pure returns (uint minute) {\n    uint secs = timestamp % SECONDS_PER_HOUR;\n    minute = secs / SECONDS_PER_MINUTE;\n  }\n  function getSecond(uint timestamp) internal pure returns (uint second) {\n    second = timestamp % SECONDS_PER_MINUTE;\n  }\n\n  function addYears(\n    uint timestamp,\n    uint _years\n  ) internal pure returns (uint newTimestamp) {\n    (uint year, uint month, uint day) = _daysToDate(\n      timestamp / SECONDS_PER_DAY\n    );\n    year += _years;\n    uint daysInMonth = _getDaysInMonth(year, month);\n    if (day > daysInMonth) {\n      day = daysInMonth;\n    }\n    newTimestamp =\n      _daysFromDate(year, month, day) * SECONDS_PER_DAY +\n      (timestamp % SECONDS_PER_DAY);\n    require(newTimestamp >= timestamp);\n  }\n  function addMonths(\n    uint timestamp,\n    uint _months\n  ) internal pure returns (uint newTimestamp) {\n    (uint year, uint month, uint day) = _daysToDate(\n      timestamp / SECONDS_PER_DAY\n    );\n    month += _months;\n    year += (month - 1) / 12;\n    month = ((month - 1) % 12) + 1;\n    uint daysInMonth = _getDaysInMonth(year, month);\n    if (day > daysInMonth) {\n      day = daysInMonth;\n    }\n    newTimestamp =\n      _daysFromDate(year, month, day) * SECONDS_PER_DAY +\n      (timestamp % SECONDS_PER_DAY);\n    require(newTimestamp >= timestamp);\n  }\n  function addDays(\n    uint timestamp,\n    uint _days\n  ) internal pure returns (uint newTimestamp) {\n    newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n    require(newTimestamp >= timestamp);\n  }\n  function addHours(\n    uint timestamp,\n    uint _hours\n  ) internal pure returns (uint newTimestamp) {\n    newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n    require(newTimestamp >= timestamp);\n  }\n  function addMinutes(\n    uint timestamp,\n    uint _minutes\n  ) internal pure returns (uint newTimestamp) {\n    newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n    require(newTimestamp >= timestamp);\n  }\n  function addSeconds(\n    uint timestamp,\n    uint _seconds\n  ) internal pure returns (uint newTimestamp) {\n    newTimestamp = timestamp + _seconds;\n    require(newTimestamp >= timestamp);\n  }\n\n  function subYears(\n    uint timestamp,\n    uint _years\n  ) internal pure returns (uint newTimestamp) {\n    (uint year, uint month, uint day) = _daysToDate(\n      timestamp / SECONDS_PER_DAY\n    );\n    year -= _years;\n    uint daysInMonth = _getDaysInMonth(year, month);\n    if (day > daysInMonth) {\n      day = daysInMonth;\n    }\n    newTimestamp =\n      _daysFromDate(year, month, day) * SECONDS_PER_DAY +\n      (timestamp % SECONDS_PER_DAY);\n    require(newTimestamp <= timestamp);\n  }\n  function subMonths(\n    uint timestamp,\n    uint _months\n  ) internal pure returns (uint newTimestamp) {\n    (uint year, uint month, uint day) = _daysToDate(\n      timestamp / SECONDS_PER_DAY\n    );\n    uint yearMonth = year * 12 + (month - 1) - _months;\n    year = yearMonth / 12;\n    month = (yearMonth % 12) + 1;\n    uint daysInMonth = _getDaysInMonth(year, month);\n    if (day > daysInMonth) {\n      day = daysInMonth;\n    }\n    newTimestamp =\n      _daysFromDate(year, month, day) * SECONDS_PER_DAY +\n      (timestamp % SECONDS_PER_DAY);\n    require(newTimestamp <= timestamp);\n  }\n  function subDays(\n    uint timestamp,\n    uint _days\n  ) internal pure returns (uint newTimestamp) {\n    newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n    require(newTimestamp <= timestamp);\n  }\n  function subHours(\n    uint timestamp,\n    uint _hours\n  ) internal pure returns (uint newTimestamp) {\n    newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n    require(newTimestamp <= timestamp);\n  }\n  function subMinutes(\n    uint timestamp,\n    uint _minutes\n  ) internal pure returns (uint newTimestamp) {\n    newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n    require(newTimestamp <= timestamp);\n  }\n  function subSeconds(\n    uint timestamp,\n    uint _seconds\n  ) internal pure returns (uint newTimestamp) {\n    newTimestamp = timestamp - _seconds;\n    require(newTimestamp <= timestamp);\n  }\n\n  function diffYears(\n    uint fromTimestamp,\n    uint toTimestamp\n  ) internal pure returns (uint _years) {\n    require(fromTimestamp <= toTimestamp);\n    (uint fromYear, , ) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n    (uint toYear, , ) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n    _years = toYear - fromYear;\n  }\n  function diffMonths(\n    uint fromTimestamp,\n    uint toTimestamp\n  ) internal pure returns (uint _months) {\n    require(fromTimestamp <= toTimestamp);\n    (uint fromYear, uint fromMonth, ) = _daysToDate(\n      fromTimestamp / SECONDS_PER_DAY\n    );\n    (uint toYear, uint toMonth, ) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n    _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n  }\n  function diffDays(\n    uint fromTimestamp,\n    uint toTimestamp\n  ) internal pure returns (uint _days) {\n    require(fromTimestamp <= toTimestamp);\n    _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n  }\n  function diffHours(\n    uint fromTimestamp,\n    uint toTimestamp\n  ) internal pure returns (uint _hours) {\n    require(fromTimestamp <= toTimestamp);\n    _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n  }\n  function diffMinutes(\n    uint fromTimestamp,\n    uint toTimestamp\n  ) internal pure returns (uint _minutes) {\n    require(fromTimestamp <= toTimestamp);\n    _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n  }\n  function diffSeconds(\n    uint fromTimestamp,\n    uint toTimestamp\n  ) internal pure returns (uint _seconds) {\n    require(fromTimestamp <= toTimestamp);\n    _seconds = toTimestamp - fromTimestamp;\n  }\n}\n"
      },
      "project/contracts/core/CalculationLogic.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport {HelpersLib} from \"./HelpersLib.sol\";\n\ncontract CalculationLogic {\n  event MaxStepSet(uint256 steps);\n\n  uint256 weeklyCalculationStartTime;\n  uint256 maxSteps = 5;\n  uint256 bvBalance = 500 ether;\n  uint256 commissionPerStep = 60 ether;\n\n  function _activateWeeklyCalculateion(uint256 timestamp) internal {\n    require(\n      weeklyCalculationStartTime == 0,\n      \"Calculation logic is already switched to weekly\"\n    );\n\n    uint256 weekNumber = HelpersLib.getWeekOfTs(timestamp);\n    weeklyCalculationStartTime = HelpersLib.getStartWeekTs(weekNumber + 1);\n    maxSteps = 20;\n    bvBalance = 600 ether;\n    commissionPerStep = 70 ether;\n  }\n\n  function _setWeeklyMaxSteps(uint256 steps) internal {\n    require(steps >= 5 && steps <= 20, \"Max steps must be between 5 - 20\");\n    maxSteps = steps;\n\n    emit MaxStepSet(steps);\n  }\n}\n"
      },
      "project/contracts/core/Core.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {Users} from \"./Users.sol\";\nimport {Sellers} from \"./Sellers.sol\";\nimport {SellerLib} from \"./SellerLib.sol\";\nimport {Orders} from \"./Orders.sol\";\nimport {OrderLib} from \"./OrderLib.sol\";\nimport {UserLib} from \"./UserLib.sol\";\nimport {HelpersLib} from \"./HelpersLib.sol\";\nimport {Finance} from \"./Finance.sol\";\nimport {FastValue} from \"./FastValue.sol\";\nimport {CalculationLogic} from \"./CalculationLogic.sol\";\nimport {CoreLib} from \"./CoreLib.sol\";\nimport {SecurityGuard} from \"./SecurityGuard.sol\";\n\n/**\n * @title AranDAOPro - Multi-Level Marketing Binary Tree Contract\n * @notice Implements a secure, gas-conscious MLM tree structure with on-chain order bookkeeping\n * @dev Each node can have up to 4 children (positions 0-3). Path encoding uses bytes32 arrays\n *      where each byte represents a position (0x00-0x03). Supports efficient subtree calculations\n *      and commission tracking via lastCalculatedOrder mechanism.\n *\n * Path Encoding:\n * - Each bytes32 contains up to 32 path levels\n * - Each byte holds values 0x00, 0x01, 0x02, 0x03 representing positions 0-3\n * - When path exceeds 32 levels, new bytes32 is appended to array\n *\n * isSubTree Semantics:\n * - Returns (true, position) if candidate is in subtree via direct child at position\n * - Returns (true, 255) when candidate == root (sentinel value for same node)\n * - Returns (false, 0) if not in subtree\n */\ncontract AranDaoProCore is\n  ReentrancyGuard,\n  Users,\n  Sellers,\n  Orders,\n  Finance,\n  FastValue,\n  CalculationLogic,\n  SecurityGuard\n{\n  /// @notice Amount data structure containing both SV and BV values\n  struct Amount {\n    address sellerAddress;\n    uint256 sv; // Sales Volume\n    uint256 bv; // Business Volume\n  }\n\n  /// @notice Maps day to total global steps for that day\n  mapping(uint256 => uint256) globalDailySteps;\n\n  /// @notice Maps day to flush-out counter for that day\n  mapping(uint256 => uint256) globalDailyFlushOuts;\n\n  constructor(\n    address _initAdmin,\n    address _dnmAddress,\n    address _paymentTokenAddress,\n    address _vaultAddress\n  )\n    Finance(_paymentTokenAddress, _dnmAddress, _vaultAddress)\n    SecurityGuard(_initAdmin)\n  {}\n\n  /**\n   * @notice Registers a new user in the MLM tree\n   * @dev First user must have parentId=0 and position=0. All others need valid parent.\n   *      Path is computed by copying parent's path and appending new position.\n   * @param userAddr The EOA address to register\n   * @param parentId The parent user ID (0 for root user only)\n   * @param position The position under parent (0-3)\n   */\n  function migrateUser(\n    address userAddr,\n    uint256 parentId,\n    uint8 position,\n    uint256 bv,\n    uint256 withdrawableCommission,\n    uint256[4] memory childrenSafeBv,\n    uint256[4] memory childrenAggregateBv\n  ) external onlyMigrateOperator {\n    _migrateUser(\n      userAddr,\n      parentId,\n      position,\n      bv,\n      withdrawableCommission,\n      childrenSafeBv,\n      childrenAggregateBv,\n      lastOrderId\n    );\n  }\n\n  /**\n   * @notice Creates new orders for commission calculation\n   * @dev Buyer and seller will be automatically registered if they don't exist.\n   *      For new users, total BV must be greater than 100 ether.\n   * @param buyerAddress The buyer's EOA address\n   * @param parentAddress The parent's EOA address (for user creation)\n   * @param position The position under parent (0-3, for user creation)\n   * @param amounts Array of Amount structs containing SV and BV values\n   */\n\n  function createOrder(\n    address buyerAddress,\n    address parentAddress,\n    uint8 position,\n    Amount[] calldata amounts\n  ) external onlyOrderCreatorContracts(msg.sender) {\n    require(amounts.length > 0, \"At least one amount required\");\n\n    bool isUserExisted = _userExistsByAddress(buyerAddress);\n\n    uint256 totalBv = 0;\n    for (uint256 i = 0; i < amounts.length; i++) {\n      totalBv += amounts[i].bv;\n    }\n\n    // If new user, validate minimum BV requirement\n    if (!isUserExisted) {\n      if (totalBv < 100 ether) revert CoreLib.InsufficientBVForNewUser();\n    }\n\n    uint256 buyerId = _getOrCreateUser(\n      buyerAddress,\n      parentAddress,\n      position,\n      lastOrderId\n    );\n    uint256 weekNumber = HelpersLib.getWeekOfTs(block.timestamp);\n\n    // Process each amount and create orders\n    for (uint256 i = 0; i < amounts.length; i++) {\n      uint256 sellerId = _getOrCreateSeller(amounts[i].sellerAddress);\n\n      _createOrder(buyerId, sellerId, amounts[i].sv, amounts[i].bv);\n      _addSellerBv(sellerId, weekNumber, amounts[i].bv);\n    }\n\n    _addUserBv(buyerId, weekNumber, totalBv);\n    _addTotalWeekBv(weekNumber, totalBv);\n    _addMonthlyFv((totalBv * 20) / 100); // FV = 20% * BV;\n\n    UserLib.User storage user = _getUserById(buyerId);\n\n    //Add user to fast value if conditions are passed.\n    if (!user.migrated && user.fvEntranceMonth != 0) {\n      uint256 month = HelpersLib.getMonth(block.timestamp);\n      if (user.fvEntranceMonth + 12 > month) {\n        for (uint8 i = 1; i < 12; i++) {\n          uint256 requiredBvForFastValue = (100 ether * (12 ** i)) / (10 ** i);\n          if (user.bv < requiredBvForFastValue) {\n            break;\n          }\n          _submitUserForFastValue(\n            buyerId,\n            user.fvEntranceMonth + i,\n            user.fvEntranceShare\n          );\n        }\n      }\n    }\n  }\n\n  function withdrawFastValueShare() public nonReentrant {\n    uint256 userId = getUserIdByAddress(msg.sender);\n    uint256 month = HelpersLib.getMonth(block.timestamp);\n\n    uint8 userShare = monthlyUserShares[month][userId];\n    bool isWithdrawm = monthlyUserShareWithdraws[month][userId];\n\n    if (userShare == 0) {\n      revert CoreLib.UserHasNoFastValueShares();\n    }\n\n    if (isWithdrawm) {\n      revert CoreLib.UserHasAlreadyWithdrawnFastValueShare();\n    }\n\n    uint256 pastMonth = HelpersLib.getMonth(block.timestamp) - 1;\n    uint256 userFvShare = _getUserShare(userId, pastMonth);\n\n    bool isPaymentSuccessful = _transferPaymentToken(msg.sender, userFvShare);\n\n    require(isPaymentSuccessful, \"Token payment error\");\n\n    monthlyUserShareWithdraws[pastMonth][userId] = true;\n\n    emit CoreLib.MontlyFastValueWithdrawn(userId, month, userFvShare);\n  }\n\n  /**\n   * @notice Processes orders for commission calculation with gas limit protection\n   * @dev Iterates through orders starting from lastCalculatedOrder + 1, updating\n   *      childrenBv for direct children whose subtrees contain the buyers\n   * @param callerId The user ID to calculate commissions for\n   * @param orderIds Array of proccessable orderIds.\n   */\n  function calculateOrders(\n    uint256 callerId,\n    uint256[] memory orderIds\n  ) external onlyManager(msg.sender) {\n    UserLib.User storage user = _getUserById(callerId);\n\n    uint256 lastCalculatedOrderDate = _getOrderById(user.lastCalculatedOrder)\n      .createdAt;\n\n    uint16 orderIdsLen = uint16(orderIds.length);\n\n    require(\n      orderIdsLen < 255,\n      \"Maximum number of 255 orders can be proccessed in a single transaction.\"\n    );\n\n    for (uint8 i = 0; i < orderIdsLen; i++) {\n      require(\n        orderIds[i] > user.lastCalculatedOrder,\n        \"Order with greater ID is already processed for this user.\"\n      );\n\n      OrderLib.Order memory order = _getOrderById(orderIds[i]);\n\n      if (\n        weeklyCalculationStartTime > 0 &&\n        weeklyCalculationStartTime < block.timestamp\n      ) {\n        require(\n          HelpersLib.getWeekOfTs(order.createdAt) <\n            HelpersLib.getWeekOfTs(block.timestamp),\n          \"Cannot process orders from current week.\"\n        );\n\n        if (\n          HelpersLib.getWeekOfTs(lastCalculatedOrderDate) <\n          HelpersLib.getWeekOfTs(order.createdAt)\n        ) {\n          calculateWeeklyCommission(callerId, lastCalculatedOrderDate);\n        }\n      } else {\n        require(\n          HelpersLib.getDayOfTs(order.createdAt) <\n            HelpersLib.getDayOfTs(block.timestamp),\n          \"Cannot process orders from current day.\"\n        );\n\n        if (\n          HelpersLib.getDayOfTs(lastCalculatedOrderDate) <\n          HelpersLib.getDayOfTs(order.createdAt)\n        ) {\n          calculateDailyCommission(callerId, lastCalculatedOrderDate);\n        }\n      }\n\n      (bool inSubTree, uint8 childPosition) = _isSubTree(\n        callerId,\n        order.buyerId\n      );\n\n      if (inSubTree && childPosition != SAME_NODE_SENTINEL) {\n        // Accumulate BV update for the direct child position\n        user.childrenBv[childPosition] += order.bv;\n        user.normalNodesBv[childPosition / 2] += order.bv;\n      }\n\n      lastCalculatedOrderDate = order.createdAt;\n    }\n\n    user.lastCalculatedOrder = orderIds[orderIdsLen - 1];\n\n    emit CoreLib.OrdersCalculated(\n      callerId,\n      orderIdsLen,\n      orderIds[orderIdsLen - 1]\n    );\n  }\n\n  /**\n   * @notice Internal shared logic for daily/weekly commission calculation\n   * @param userId The user ID to calculate commission for\n   * @param periodDayNumber Day identifier used for step tracking\n   *        - For daily: actual day number\n   *        - For weekly: start day of the week (weekNumber * 7)\n   * @param isWeekly Whether calculation is for weekly period\n   * @param lastOrderTimestamp Timestamp of the last processed order (used for daily activation threshold)\n   */\n  function _calculateCommissionForPeriod(\n    uint256 userId,\n    uint256 periodDayNumber,\n    bool isWeekly,\n    uint256 lastOrderTimestamp\n  ) internal {\n    UserLib.User storage user = _getUserById(userId);\n    uint256 totalUserCommissionEarned = 0;\n\n    for (uint8 pairIndex = 0; pairIndex < 3; pairIndex++) {\n      (uint256 leftBv, uint256 rightBv) = _getUserPairByIndex(\n        userId,\n        pairIndex\n      );\n\n      uint8 currentSteps = _getUserDailySteps(\n        userId,\n        periodDayNumber,\n        pairIndex\n      );\n\n      while (\n        leftBv >= bvBalance && rightBv >= bvBalance && currentSteps <= maxSteps\n      ) {\n        leftBv -= bvBalance;\n        rightBv -= bvBalance;\n\n        totalUserCommissionEarned += commissionPerStep;\n\n        currentSteps++;\n        globalDailySteps[periodDayNumber]++;\n      }\n\n      if (currentSteps > 0) {\n        checkUserAuthorityForFvEntrance(userId);\n      }\n\n      _setUserPairByIndex(userId, leftBv, rightBv, pairIndex);\n\n      _setUserDailySteps(userId, periodDayNumber, pairIndex, currentSteps);\n\n      if (currentSteps == maxSteps) {\n        _setUserPairByIndex(userId, 0, 0, pairIndex);\n        globalDailyFlushOuts[periodDayNumber]++;\n\n        if (isWeekly) {\n          emit CoreLib.UserWeeklyFlushedOut(userId, periodDayNumber / 7);\n        } else {\n          if (globalDailyFlushOuts[periodDayNumber] >= 95) {\n            _activateWeeklyCalculateion(lastOrderTimestamp);\n          }\n          emit CoreLib.UserDailyFlushedOut(userId, periodDayNumber);\n        }\n      }\n\n      if (isWeekly) {\n        emit CoreLib.WeeklyCommissionCalculated(\n          userId,\n          periodDayNumber / 7,\n          totalUserCommissionEarned,\n          pairIndex,\n          currentSteps\n        );\n      } else {\n        emit CoreLib.DailyCommissionCalculated(\n          userId,\n          periodDayNumber,\n          totalUserCommissionEarned,\n          pairIndex,\n          currentSteps\n        );\n      }\n    }\n\n    totalCommissionEarned += totalUserCommissionEarned;\n    user.withdrawableCommission += totalUserCommissionEarned;\n  }\n\n  /**\n   * @notice Calculates daily commission for a specific user based on their BV pairs\n   * @dev Processes 3 pairs: childrenBv[0-1], childrenBv[2-3], and normalNodesBv[0-1]\n   *      Each pair can have max 6 steps per day. At 6 steps, both sides are flushed to 0.\n   * @param userId The user ID to calculate commission for\n   */\n  function calculateDailyCommission(\n    uint256 userId,\n    uint256 lastOrderTimestamp\n  ) internal {\n    uint256 dayNumber = HelpersLib.getDayOfTs(lastOrderTimestamp);\n    _calculateCommissionForPeriod(userId, dayNumber, false, lastOrderTimestamp);\n  }\n\n  /**\n   * @notice Calculates weekly commission for a specific user based on their BV pairs\n   * @dev Processes 3 pairs: childrenBv[0-1], childrenBv[2-3], and normalNodesBv[0-1]\n   *      Each pair can have max 6 steps per day. At 6 steps, both sides are flushed to 0.\n   * @param userId The user ID to calculate commission for\n   */\n  function calculateWeeklyCommission(\n    uint256 userId,\n    uint256 lastOrderTimestamp\n  ) internal {\n    uint256 dayNumber = HelpersLib.getWeekOfTs(lastOrderTimestamp) * 7;\n    _calculateCommissionForPeriod(userId, dayNumber, true, lastOrderTimestamp);\n  }\n\n  function checkUserAuthorityForFvEntrance(uint256 userId) internal {\n    UserLib.User storage user = _getUserById(userId);\n    if (!user.migrated) {\n      uint256 month = HelpersLib.getMonth(block.timestamp);\n      if (user.createdAt + 30 days > block.timestamp) {\n        _submitUserForFastValue(userId, month, 2);\n      } else if (user.createdAt + 60 days > block.timestamp) {\n        _submitUserForFastValue(userId, month, 1);\n      }\n    }\n  }\n\n  /**\n   * @notice Allows a user to withdraw their accumulated commission\n   * @param amount The amount to withdraw\n   */\n  function withdrawCommission(uint256 amount) external nonReentrant {\n    uint256 userId = getUserIdByAddress(msg.sender);\n    UserLib.User storage user = _getUserById(userId);\n    require(\n      amount <= user.withdrawableCommission,\n      \"Insufficient commission balance\"\n    );\n\n    bool isTxSuccessful = _transferPaymentToken(msg.sender, amount);\n\n    require(isTxSuccessful, \"Error while transfering payment token to user\");\n\n    user.withdrawableCommission -= amount;\n    totalCommissionEarned -= amount;\n\n    emit CoreLib.CommissionWithdrawn(userId, amount);\n  }\n\n  function mintWeeklyDnm() public nonReentrant {\n    _mintWeeklyDnm();\n  }\n\n  function calculateNetworkerWeeklyDnm() public nonReentrant {\n    uint256 userId = getUserIdByAddress(msg.sender);\n    UserLib.User storage user = users[userId];\n    uint256 passedWeekNumber = HelpersLib.getWeekOfTs(block.timestamp) - 1;\n\n    if (passedWeekNumber > dnmMintWeekNumber) {\n      mintWeeklyDnm();\n    }\n\n    require(\n      user.lastDnmWithdrawNetworkerWeekNumber < passedWeekNumber,\n      \"Networker has already calculated DNM for this week.\"\n    );\n\n    uint256 userWeekSteps = 0;\n    uint256 totalWeekSteps = 0;\n\n    for (uint8 i = 0; i < 7; i++) {\n      uint256 dayNumber = (passedWeekNumber) * 7 + i;\n      totalWeekSteps = globalDailySteps[dayNumber];\n      for (uint8 j = 0; j < 3; j++) {\n        userWeekSteps += _getUserDailySteps(userId, dayNumber, j);\n      }\n    }\n\n    uint256 networkerDnmShare = (((lastWeekDnmMintAmount * 60) / 100) *\n      userWeekSteps) / totalWeekSteps;\n\n    totalDnmEarned += ((networkerDnmShare * 30) / 100);\n    user.networkerDnmShare += ((networkerDnmShare * 30) / 100);\n\n    _transferDnm(msg.sender, (networkerDnmShare * 70) / 100);\n\n    emit CoreLib.NetworkerDnmShareCalculated(\n      userId,\n      passedWeekNumber,\n      networkerDnmShare\n    );\n  }\n\n  function calculateUserWeeklyDnm() public nonReentrant {\n    uint256 userId = getUserIdByAddress(msg.sender);\n    UserLib.User storage user = users[userId];\n    uint256 passedWeekNumber = HelpersLib.getWeekOfTs(block.timestamp) - 1;\n\n    if (passedWeekNumber > dnmMintWeekNumber) {\n      mintWeeklyDnm();\n    }\n\n    require(\n      user.lastDnmWithdrawUserWeekNumber < passedWeekNumber,\n      \"User has already calculated DNM for this week.\"\n    );\n\n    uint256 userDnmShare = (((lastWeekDnmMintAmount * 35) / 100) *\n      _getUserWeeklyBv(userId, passedWeekNumber)) /\n      _getWeeklyBv(passedWeekNumber);\n\n    _transferDnm(msg.sender, userDnmShare);\n\n    emit CoreLib.UserDnmShareCalculated(userId, passedWeekNumber, userDnmShare);\n  }\n\n  function calculateSellerWeeklyDnm() public nonReentrant {\n    uint256 sellerId = getSellerIdByAddress(msg.sender);\n    SellerLib.Seller storage seller = _getSellerById(sellerId);\n    uint256 passedWeekNumber = HelpersLib.getWeekOfTs(block.timestamp) - 1;\n\n    if (passedWeekNumber > dnmMintWeekNumber) {\n      mintWeeklyDnm();\n    }\n\n    require(\n      seller.lastDnmWithdrawWeekNumber < passedWeekNumber,\n      \"Seller has already calculated DNM for this week.\"\n    );\n\n    uint256 sellerDnmShare = (((lastWeekDnmMintAmount * 5) / 100) *\n      sellerWeeklyBv[sellerId][passedWeekNumber]) /\n      _getWeeklyBv(passedWeekNumber);\n\n    _transferDnm(msg.sender, sellerDnmShare);\n\n    emit CoreLib.SellerDnmShareCalculated(\n      sellerId,\n      passedWeekNumber,\n      sellerDnmShare\n    );\n  }\n\n  function monthlyWithdrawNetworkerDnm() public nonReentrant {\n    uint256 userId = getUserIdByAddress(msg.sender);\n    UserLib.User storage user = users[userId];\n\n    uint256 month = HelpersLib.getMonth(block.timestamp);\n    require(\n      month >= user.withdrawNetworkerDnmShareMonth + 3,\n      \"User has already withdrawn DNM share for this 3 month period\"\n    );\n\n    uint256 dnmAmount = (user.networkerDnmShare * 25) / 100;\n    _transferDnm(msg.sender, dnmAmount);\n\n    user.networkerDnmShare -= dnmAmount;\n    user.withdrawNetworkerDnmShareMonth = month;\n    totalDnmEarned -= dnmAmount;\n\n    emit CoreLib.NetworkerMonthlyDnmShareWithdrawn(userId, month, dnmAmount);\n  }\n\n  function setMaxSteps(uint256 steps) public onlyManager(msg.sender) {\n    _setWeeklyMaxSteps(steps);\n  }\n}\n"
      },
      "project/contracts/core/CoreLib.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nlibrary CoreLib {\n  /// @notice Emitted when orders are processed for commission calculation\n  /// @param userId The user ID for whom orders were calculated\n  /// @param processed Number of orders processed in this call\n  /// @param lastCalculatedOrder New value of lastCalculatedOrder for this user\n  event OrdersCalculated(\n    uint256 indexed userId,\n    uint256 processed,\n    uint256 lastCalculatedOrder\n  );\n\n  /// @notice Emitted when daily commission is calculated for a user\n  /// @param userId The user ID for whom commission was calculated\n  /// @param day The day (timestamp / 86400) for the calculation\n  /// @param totalCommission The total commission amount earned\n  /// @param pairProcessed The number of pairs that had steps processed\n  event DailyCommissionCalculated(\n    uint256 indexed userId,\n    uint256 indexed day,\n    uint256 totalCommission,\n    uint8 pairProcessed,\n    uint256 steps\n  );\n\n  /// @notice Emitted when daily commission is calculated for a user\n  /// @param userId The user ID for whom commission was calculated\n  /// @param week The week (timestamp / 86400 / 7) for the calculation\n  /// @param totalCommission The total commission amount earned\n  /// @param pairProcessed The number of pairs that had steps processed\n  event WeeklyCommissionCalculated(\n    uint256 indexed userId,\n    uint256 indexed week,\n    uint256 totalCommission,\n    uint8 pairProcessed,\n    uint256 steps\n  );\n\n  /// @notice Emitted when DNM share is calculated for networker\n  event NetworkerDnmShareCalculated(\n    uint256 indexed userId,\n    uint256 indexed week,\n    uint256 share\n  );\n\n  /// @notice Emitted when DNM share is calculated for user\n  event UserDnmShareCalculated(\n    uint256 indexed userId,\n    uint256 indexed week,\n    uint256 share\n  );\n\n  /// @notice Emitted when DNM share is calculated for seller\n  event SellerDnmShareCalculated(\n    uint256 indexed sellerId,\n    uint256 indexed week,\n    uint256 share\n  );\n\n  /// @notice Emitted when monthly DNM share is withdrawn by networker\n  event NetworkerMonthlyDnmShareWithdrawn(\n    uint256 indexed userId,\n    uint256 indexed month,\n    uint256 share\n  );\n\n  event UserDailyFlushedOut(uint256 indexed userId, uint256 indexed day);\n  event UserWeeklyFlushedOut(uint256 indexed userId, uint256 indexed week);\n\n  /// @notice Emitted when a user withdraws commission\n  /// @param userId The user ID who withdrew\n  /// @param amount The amount withdrawn\n  event CommissionWithdrawn(uint256 indexed userId, uint256 amount);\n\n  event MontlyFastValueWithdrawn(uint256 userId, uint256 month, uint256 share);\n\n  // Custom errors\n  error InsufficientBVForNewUser();\n  error UserHasNoFastValueShares();\n  error UserHasAlreadyWithdrawnFastValueShare();\n}\n"
      },
      "project/contracts/core/FastValue.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport {HelpersLib} from \"./HelpersLib.sol\";\n\ncontract FastValue {\n  event UserAddedToFastValue(uint256 userId, uint8 share);\n\n  mapping(uint256 => mapping(uint256 => uint8)) public monthlyUserShares; //month to user ID to user share. share can be 0 - 2\n  mapping(uint256 => mapping(uint256 => bool)) public monthlyUserShareWithdraws; //month to user ID to a boolean which shows if the user is withdrawn his share.\n  mapping(uint256 => uint256) public monthlyTotalShares; //month to total share count\n  mapping(uint256 => uint256) public monthlyFv; //month to total fast value;\n\n  function _submitUserForFastValue(\n    uint256 userId,\n    uint256 month,\n    uint8 share\n  ) internal {\n    if (monthlyUserShares[month][userId] == 0) {\n      monthlyUserShares[month][userId] = share;\n      monthlyTotalShares[month] += share;\n\n      emit UserAddedToFastValue(userId, share);\n    }\n  }\n\n  function _addMonthlyFv(uint256 amount) internal {\n    uint256 month = HelpersLib.getMonth(block.timestamp);\n    monthlyFv[month] += amount;\n  }\n\n  function _getUserShare(\n    uint256 userId,\n    uint256 month\n  ) internal view returns (uint256) {\n    if (\n      monthlyUserShares[month][userId] == 0 ||\n      monthlyUserShareWithdraws[month][userId]\n    ) {\n      return 0;\n    }\n    return\n      (monthlyFv[month] * monthlyUserShares[month][userId]) /\n      monthlyTotalShares[month];\n  }\n}\n"
      },
      "project/contracts/core/Finance.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport {IDNM} from \"./IDNM.sol\";\nimport {HelpersLib} from \"./HelpersLib.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IVault} from \"./IVault.sol\";\n\ncontract Finance {\n  event weeklyDnmMinted(uint256 weekNumber, uint256 amount);\n\n  /// @notice Last calculated week DNM mint amount\n  uint256 public lastWeekDnmMintAmount = 0;\n\n  /// @notice Last DNM mint week number\n  uint256 public dnmMintWeekNumber = 0;\n\n  /// @dev Total commission earned and not withdrawn.\n  uint256 public totalCommissionEarned = 0;\n\n  /// @dev Total dnm earned and not withdrawn.\n  uint256 public totalDnmEarned = 0;\n\n  /// @dev DNM token address\n  address public dnmAddress;\n\n  /// @dev Payment token address (Could be DAI for example)\n  address public paymentTokenAddress;\n\n  /// @dev Vault contract address\n  address public vaultAddress;\n\n  /// @notice Maps week to total BV for that week\n  mapping(uint256 => uint256) public totalWeeklyBv;\n\n  constructor(\n    address _paymentTokenAddress,\n    address _dnmAddress,\n    address _vaultAddress\n  ) {\n    paymentTokenAddress = _paymentTokenAddress;\n    dnmAddress = _dnmAddress;\n    vaultAddress = _vaultAddress;\n  }\n\n  function _transferPaymentToken(\n    address to,\n    uint256 value\n  ) internal returns (bool) {\n    IERC20 paymentToken = IERC20(paymentTokenAddress);\n\n    uint256 balance = paymentToken.balanceOf(address(this));\n    if (value > balance) {\n      IVault vaultContract = IVault(vaultAddress);\n      vaultContract.withrawDai(value - balance);\n    }\n    return paymentToken.transferFrom(address(this), to, value);\n  }\n\n  function _mintWeeklyDnm() internal {\n    uint256 pastWeekNumber = HelpersLib.getWeekOfTs(block.timestamp) - 1;\n    require(\n      dnmMintWeekNumber < pastWeekNumber,\n      \"DNM of this week is already minted.\"\n    );\n    //Total BV - 20% for FV\n    uint256 pastWeekBv = (totalWeeklyBv[pastWeekNumber] * 80) / 100;\n    uint256 pastWeekFv = (totalWeeklyBv[pastWeekNumber] * 20) / 100;\n    require(pastWeekBv >= 100 ether, \"This week's BV is less than 100.\");\n\n    IVault vaultContract = IVault(vaultAddress);\n\n    uint256 priceFromDex = vaultContract.getPrice();\n\n    IDNM dnmContract = IDNM(dnmAddress);\n    uint256 currentExcessDnmBalance = dnmContract.balanceOf(address(this)) -\n      totalDnmEarned -\n      pastWeekFv;\n\n    //Price = ((Remaining BV) + (DEX stock price)) / TOTAL SUPPLY\n    uint256 p = (pastWeekBv + priceFromDex - totalCommissionEarned) /\n      (dnmContract.totalSupply() - currentExcessDnmBalance);\n\n    //mint amount = (.078 * total BV) / Price\n    uint256 mintAmount = ((pastWeekBv * 78) / 1000) / p;\n\n    dnmContract.mint(address(this), mintAmount - currentExcessDnmBalance);\n\n    IERC20 paymentToken = IERC20(paymentTokenAddress);\n    uint256 dexTransferAmount = paymentToken.balanceOf(address(this)) -\n      totalCommissionEarned;\n\n    // Approve vault to take the amount that core wants to transfer\n    paymentToken.approve(vaultAddress, dexTransferAmount);\n\n    // Transfer token to dex\n    vaultContract.deposit(dexTransferAmount);\n\n    lastWeekDnmMintAmount = mintAmount;\n    dnmMintWeekNumber = pastWeekNumber;\n\n    emit weeklyDnmMinted(pastWeekNumber, mintAmount);\n  }\n\n  function _transferDnm(address to, uint256 amount) internal returns (bool) {\n    IDNM dnmToken = IDNM(dnmAddress);\n    return dnmToken.transferFrom(address(this), to, amount);\n  }\n\n  function _addTotalWeekBv(uint256 weekNumber, uint256 amount) internal {\n    totalWeeklyBv[weekNumber] += amount;\n  }\n\n  function _getWeeklyBv(uint256 weekNumber) internal view returns (uint256) {\n    return totalWeeklyBv[weekNumber];\n  }\n}\n"
      },
      "project/contracts/core/HelpersLib.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport {BokkyPooBahsDateTimeLibrary} from \"./BokkyPooBahsDateTimeLibrary.sol\";\n\nlibrary HelpersLib {\n  // Mon 29 Sep 2025\n  uint256 constant offset = 1759091400;\n\n  /**\n   * @notice Gets the current day number from 29 Sep 2025 (timestamp / 86400)\n   * @return The current day number\n   */\n  function getDayOfTs(uint256 timestamp) internal pure returns (uint256) {\n    return (timestamp - offset) / 86400;\n  }\n\n  /**\n   * @notice Gets the current week number from 29 Sep 2025\n   * @return The current week number\n   */\n  function getWeekOfTs(uint256 timestamp) internal pure returns (uint256) {\n    return getDayOfTs(timestamp) / 7;\n  }\n\n  function getStartWeekTs(uint256 weekNumber) internal pure returns (uint256) {\n    return (weekNumber * 7 * 86400) + offset;\n  }\n\n  function getMonth(uint256 timestamp) internal pure returns (uint256) {\n    (uint year, uint month, ) = BokkyPooBahsDateTimeLibrary.timestampToDate(\n      timestamp\n    );\n\n    return ((year - 2025) * 12 + month);\n  }\n}\n"
      },
      "project/contracts/core/IDNM.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IDNM is IERC20 {\n  function mint(address to, uint256 amount) external;\n}\n"
      },
      "project/contracts/core/IVault.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\ninterface IVault {\n  function deposit(uint256 amountToDeposit) external;\n  function withrawDai(uint256 amount) external;\n  function getPrice() external view returns (uint256);\n}\n"
      },
      "project/contracts/core/OrderLib.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nlibrary OrderLib {\n  /// @notice Order data structure for tracking purchases\n  struct Order {\n    uint256 buyerId; // User ID who made the purchase\n    uint256 sellerId; // Seller ID who made the sale\n    uint256 sv; // Sales value\n    uint256 bv; // Business value\n    bool existed;\n    uint256 createdAt; // Block timestamp of order\n  }\n\n  /// @notice Emitted when a new order is created\n  /// @param orderId The assigned order ID\n  /// @param buyerId The user ID who made the purchase\n  /// @param amount The purchase amount\n  event OrderCreated(\n    uint256 indexed orderId,\n    uint256 indexed buyerId,\n    uint256 amount\n  );\n\n  error OrderNotExisted(uint256 orderId);\n}\n"
      },
      "project/contracts/core/Orders.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport {OrderLib} from \"./OrderLib.sol\";\n\ncontract Orders {\n  /// @notice Maps order IDs to Order structs\n  mapping(uint256 => OrderLib.Order) orders;\n\n  /// @notice Current highest order ID\n  uint256 lastOrderId = 1;\n\n  modifier onlyExistedOrder(uint256 orderId) {\n    if (!orders[orderId].existed) {\n      revert OrderLib.OrderNotExisted(orderId);\n    }\n    _;\n  }\n\n  function _createOrder(\n    uint256 buyerId,\n    uint256 sellerId,\n    uint256 bv,\n    uint256 sv\n  ) internal {\n    uint256 newOrderId = lastOrderId++;\n\n    orders[newOrderId] = OrderLib.Order({\n      buyerId: buyerId,\n      sellerId: sellerId,\n      sv: sv,\n      bv: bv,\n      existed: true,\n      createdAt: block.timestamp\n    });\n\n    emit OrderLib.OrderCreated(newOrderId, buyerId, bv);\n  }\n\n  function _getOrderById(\n    uint256 orderId\n  ) internal view onlyExistedOrder(orderId) returns (OrderLib.Order storage) {\n    return orders[orderId];\n  }\n\n  function getOrderById(uint256 orderId) public view returns (OrderLib.Order memory) {\n    return _getOrderById(orderId);\n  }\n}\n"
      },
      "project/contracts/core/SecurityGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\ncontract SecurityGuard {\n  error UnauthorizedContract(address contractAddress);\n  error UnauthorizedAddress(address _address);\n\n  /// @dev The timestamp of the contract deployment.\n  uint256 deploymentTs;\n\n  mapping(address => bool) orderCreatorContracts;\n  mapping(address => bool) managers;\n\n  constructor(address _initManager) {\n    managers[_initManager] = true;\n    deploymentTs = block.timestamp;\n  }\n\n  modifier onlyOrderCreatorContracts(address contractAddr) {\n    if (!orderCreatorContracts[contractAddr]) {\n      revert UnauthorizedContract(contractAddr);\n    }\n    _;\n  }\n\n  modifier onlyManager(address managerAddress) {\n    if (!orderCreatorContracts[managerAddress]) {\n      revert UnauthorizedAddress(managerAddress);\n    }\n    _;\n  }\n\n  modifier onlyMigrateOperator() {\n    require(\n      deploymentTs + 7 days > block.timestamp,\n      \"The time for migration has been passed.\"\n    );\n    require(managers[msg.sender], \"Sender address is not eligible to migrate.\");\n    _;\n  }\n\n  function addManager(address _addr) public onlyManager(msg.sender) {\n    managers[_addr] = true;\n  }\n\n  function revokeManager(address _addr) public onlyManager(msg.sender) {\n    managers[_addr] = false;\n  }\n\n  function addWhiteListedContract(\n    address _addr\n  ) public onlyManager(msg.sender) {\n    orderCreatorContracts[_addr] = true;\n  }\n\n  function revokeWhiteListedContract(\n    address _addr\n  ) public onlyManager(msg.sender) {\n    orderCreatorContracts[_addr] = true;\n  }\n\n  function isOrderCreatorContract(address _addr) public view returns (bool) {\n    return orderCreatorContracts[_addr];\n  }\n\n  function isManager(address _addr) public view returns (bool) {\n    return managers[_addr];\n  }\n}\n"
      },
      "project/contracts/core/SellerLib.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nlibrary SellerLib {\n  /// @notice Seller data structure for tracking sales and commissions\n  struct Seller {\n    uint256 bv; // Total business volume generated\n    uint256 lastDnmWithdrawWeekNumber; // Seller's last week number of DNM withdraw\n    uint256 createdAt; // Block timestamp of registration\n    bool active; // Whether seller is active\n  }\n\n  /// @notice Emitted when a new seller is registered\n  /// @param sellerId The assigned seller ID\n  /// @param sellerAddr The seller's EOA address\n  event SellerRegistered(uint256 indexed sellerId, address indexed sellerAddr);\n\n  error SellerNotRegistered();\n}\n"
      },
      "project/contracts/core/Sellers.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport {SellerLib} from \"./SellerLib.sol\";\n\ncontract Sellers {\n  /// @notice Current highest seller ID for incremental assignment\n  uint256 nextSellerId = 1;\n\n  /// @notice Maps seller addresses to compact numeric seller IDs\n  mapping(address => uint256) addressToSellerId;\n\n  /// @notice Maps seller ID to week to total BV for that week\n  mapping(uint256 => mapping(uint256 => uint256)) public sellerWeeklyBv;\n\n  /// @notice Maps seller IDs to Seller structs\n  mapping(uint256 => SellerLib.Seller) sellers;\n\n  modifier onlyRegisteredSeller(uint256 sellerId) {\n    if (!sellers[sellerId].active) {\n      revert SellerLib.SellerNotRegistered();\n    }\n    _;\n  }\n\n  /**\n   * @notice Internal method to get existing seller ID or create new seller\n   * @param sellerAddr The seller's EOA address\n   * @return sellerId The seller ID (existing or newly created)\n   */\n  function _getOrCreateSeller(address sellerAddr) internal returns (uint256) {\n    uint256 sellerId = addressToSellerId[sellerAddr];\n\n    // If seller doesn't exist, create them\n    if (sellerId == 0) {\n      sellerId = nextSellerId++;\n      addressToSellerId[sellerAddr] = sellerId;\n\n      sellers[sellerId] = SellerLib.Seller({\n        bv: 0,\n        lastDnmWithdrawWeekNumber: 0,\n        createdAt: block.timestamp,\n        active: true\n      });\n\n      emit SellerLib.SellerRegistered(sellerId, sellerAddr);\n    }\n\n    return sellerId;\n  }\n\n  function _addSellerBv(\n    uint256 sellerId,\n    uint256 weekNumber,\n    uint256 amount\n  ) internal onlyRegisteredSeller(sellerId) {\n    sellers[sellerId].bv += amount;\n    sellerWeeklyBv[sellerId][weekNumber] += amount;\n  }\n\n  function _getSellerById(\n    uint256 sellerId\n  )\n    internal\n    view\n    onlyRegisteredSeller(sellerId)\n    returns (SellerLib.Seller storage)\n  {\n    SellerLib.Seller storage seller = sellers[sellerId];\n\n    return seller;\n  }\n\n  function getSellerById(uint256 sellerId) public view returns (SellerLib.Seller memory) { \n    return _getSellerById(sellerId);\n  }\n\n  function getSellerIdByAddress(\n    address sellerAddress\n  ) public view returns (uint256) {\n    return addressToSellerId[sellerAddress];\n  }\n}\n"
      },
      "project/contracts/core/UserLib.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nlibrary UserLib {\n  /// @notice User data structure containing tree position and commission tracking\n  struct User {\n    uint256 parentId; // Parent user ID (0 for root)\n    address userAddress; // Address of the user\n    uint8 position; // Position under parent (0-3)\n    bytes32[] path; // Encoded path from root to user\n    uint256 lastCalculatedOrder; // Last processed order ID for this user\n    uint256[4] childrenBv; // Accumulated BV for each direct childs of normal nodes position\n    uint256[4] childrenAggregateBv; // Accumulated BV for each direct childs of normal nodes position. Aggregated\n    uint256[2] normalNodesBv; // Accumulated BV for normal nodes\n    uint256 bv; // User's total business volume\n    uint256 bvOnBridgeTime; // User's bv when the user is bridged\n    uint256 fvEntranceMonth; // The month number where user entered fast value pool\n    uint8 fvEntranceShare; // Could be 1 for half share and 2 for whole share\n    uint256 networkerDnmShare; // The share of the user from minted DNM\n    uint256 withdrawNetworkerDnmShareMonth; // The last month user has withdrawn his DNM share\n    bool migrated; //True for users who are bridged from old smart contract\n    uint256 withdrawableCommission; // User's earned commission available for withdrawal\n    uint256 lastDnmWithdrawNetworkerWeekNumber; // User's last week number of DNM withdraw for networker\n    uint256 lastDnmWithdrawUserWeekNumber; // User's last week number of DNM withdraw for user\n    uint256 createdAt; // Block timestamp of registration\n    bool active; // Whether user is active\n  }\n\n  /// @notice Emitted when a user is migrated\n  /// @param userId The assigned user ID\n  /// @param parentId The parent user ID\n  /// @param position The position under parent (0-3)\n  /// @param userAddr The user's EOA address\n  event UserMigrated(\n    uint256 indexed userId,\n    uint256 indexed parentId,\n    uint8 position,\n    address indexed userAddr\n  );\n  /// @notice Emitted when a new user is registered\n  /// @param userId The assigned user ID\n  /// @param parentId The parent user ID\n  /// @param position The position under parent (0-3)\n  /// @param userAddr The user's EOA address\n  event UserRegistered(\n    uint256 indexed userId,\n    uint256 indexed parentId,\n    uint8 position,\n    address indexed userAddr\n  );\n\n  /// @notice Emitted when a user changes their EOA address\n  /// @param userId The user ID that changed their address\n  /// @param oldAddress The previous EOA address\n  /// @param newAddress The new EOA address\n  event AddressChanged(\n    uint256 indexed userId,\n    address indexed oldAddress,\n    address indexed newAddress\n  );\n\n  event AddressChangeRequested(\n    uint256 userId,\n    address oldAddress,\n    address newAddress\n  );\n\n  error InvalidParentId();\n  error InvalidPosition();\n  error PositionAlreadyTaken();\n  error UserAlreadyRegistered();\n  error UserNotRegistered();\n\n  error FirstUserMustBeRoot();\n  error AddressAlreadyRegistered();\n  error ParentInsufficientBVForPosition(uint8 position, uint256 parentBv);\n  error InvalidParentAddress();\n}\n"
      },
      "project/contracts/core/Users.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport {UserLib} from \"./UserLib.sol\";\n\ncontract Users {\n  /// @dev Sentinel value returned by isSubTree when candidate equals root\n  uint8 constant SAME_NODE_SENTINEL = 255;\n\n  /// @notice Current highest user ID for incremental assignment\n  uint256 nextUserId = 1;\n\n  /// @notice Maps EOA addresses to compact numeric user IDs\n  mapping(address => uint256) addressToUserId;\n\n  /// @notice Maps user IDs to User structs\n  mapping(uint256 => UserLib.User) users;\n\n  /// @notice Tracks taken positions under each parent to prevent conflicts\n  mapping(uint256 => mapping(uint8 => bool)) public positionTaken;\n\n  /// @notice Maps user ID to requested wallet address change\n  mapping(uint256 => address) public changeAddressRequests;\n\n  /// @notice Maps user ID to day to pair index to daily steps count\n  mapping(uint256 => mapping(uint256 => uint8[3])) public userDailySteps;\n\n  /// @notice Maps user ID to week to total BV for that week\n  mapping(uint256 => mapping(uint256 => uint256)) public userWeeklyBv;\n\n  /// @notice Modifier to ensure caller is registered user\n  /// @param userId The user ID to validate\n  modifier onlyRegistered(uint256 userId) {\n    if (addressToUserId[msg.sender] != userId || userId == 0) {\n      revert UserLib.UserNotRegistered();\n    }\n    _;\n  }\n\n  /**\n   * @notice Gets the total number of levels in a path\n   * @dev Counts non-zero bytes across all bytes32 elements in the path\n   * @param path The path array to measure\n   * @return length Total number of path levels\n   */\n  function _getPathLength(\n    bytes32[] storage path\n  ) internal view returns (uint256) {\n    if (path.length == 0) return 0;\n\n    // Count full bytes32 elements (each contains 32 levels)\n    uint256 length = (path.length - 1) * 32;\n\n    // Count bytes in the last bytes32\n    bytes32 lastElement = path[path.length - 1];\n    for (uint256 i = 0; i < 32; i++) {\n      if (uint8(lastElement[i]) != 0) {\n        length++;\n      } else {\n        break;\n      }\n    }\n    return length;\n  }\n\n  /**\n   * @notice Retrieves a specific byte from the path at given level index\n   * @dev Efficiently locates the correct bytes32 and byte position within it\n   * @param path The path array to read from\n   * @param levelIndex The level index to retrieve (0-based)\n   * @return The position value (0-3) at the specified level\n   */\n  function _getPathByte(\n    bytes32[] storage path,\n    uint256 levelIndex\n  ) internal view returns (uint8) {\n    uint256 bytes32Index = levelIndex / 32;\n    uint256 byteIndex = levelIndex % 32;\n\n    if (bytes32Index >= path.length) {\n      return 0;\n    }\n\n    return uint8(path[bytes32Index][byteIndex]);\n  }\n\n  /**\n   * @notice Registers a new user in the MLM tree\n   * @dev First user must have parentId=0 and position=0. All others need valid parent.\n   *      Path is computed by copying parent's path and appending new position.\n   * @param userAddr The EOA address to register\n   * @param parentId The parent user ID (0 for root user only)\n   * @param position The position under parent (0-3)\n   */\n  function _migrateUser(\n    address userAddr,\n    uint256 parentId,\n    uint8 position,\n    uint256 bv,\n    uint256 withdrawableCommission,\n    uint256[4] memory childrenSafeBv,\n    uint256[4] memory childrenAggregateBv,\n    uint256 lastOrderId\n  ) internal {\n    if (addressToUserId[userAddr] != 0) {\n      revert UserLib.UserAlreadyRegistered();\n    }\n\n    if (position > 3) {\n      revert UserLib.InvalidPosition();\n    }\n\n    // Handle first user (root) registration\n    if (nextUserId == 1) {\n      if (parentId != 0 || position != 0) {\n        revert UserLib.FirstUserMustBeRoot();\n      }\n    } else {\n      // Validate parent exists and position is available\n      if (!users[parentId].active) {\n        revert UserLib.InvalidParentId();\n      }\n\n      if (positionTaken[parentId][position]) {\n        revert UserLib.PositionAlreadyTaken();\n      }\n    }\n\n    // Assign new user ID and create user\n    uint256 newUserId = nextUserId++;\n    addressToUserId[userAddr] = newUserId;\n\n    UserLib.User storage newUser = users[newUserId];\n    newUser.parentId = parentId;\n    newUser.userAddress = userAddr;\n    newUser.position = position;\n    newUser.lastCalculatedOrder = lastOrderId;\n    newUser.bv = bv;\n    newUser.bvOnBridgeTime = bv;\n    newUser.withdrawableCommission = withdrawableCommission;\n    newUser.createdAt = block.timestamp;\n    newUser.active = true;\n    newUser.migrated = true;\n    newUser.childrenBv = childrenSafeBv;\n    newUser.childrenAggregateBv = childrenAggregateBv;\n    newUser.normalNodesBv[0] = childrenSafeBv[0] + childrenSafeBv[1];\n    newUser.normalNodesBv[1] = childrenSafeBv[2] + childrenSafeBv[3];\n\n    // Set path based on parent\n    // Root user has empty path\n    // newUser.path remains empty array\n    if (parentId != 0) {\n      // Copy parent's path and append new position\n      UserLib.User storage parent = users[parentId];\n      for (uint256 i = 0; i < parent.path.length; i++) {\n        newUser.path.push(parent.path[i]);\n      }\n      _appendToPath(newUser.path, position);\n\n      // Mark position as taken\n      positionTaken[parentId][position] = true;\n    }\n\n    emit UserLib.UserMigrated(newUserId, parentId, position, userAddr);\n  }\n\n  /**\n   * @notice Internal method to get existing user ID or create new user\n   * @param userAddr The user's EOA address\n   * @param parentAddr The parent user's EOA address\n   * @param position The position under parent (0-3)\n   * @return userId The user ID (existing or newly created)\n   */\n  function _getOrCreateUser(\n    address userAddr,\n    address parentAddr,\n    uint8 position,\n    uint256 lastOrderId\n  ) internal returns (uint256) {\n    uint256 userId = addressToUserId[userAddr];\n\n    // If user doesn't exist, create them\n    if (userId == 0) {\n      // Validate position\n      if (position > 3) {\n        revert UserLib.InvalidPosition();\n      }\n\n      // Validate parent exists (unless this is the first user)\n      uint256 parentId = addressToUserId[parentAddr];\n      if (nextUserId > 1 && parentId == 0) {\n        revert UserLib.InvalidParentAddress();\n      }\n\n      // Handle first user (root) registration\n      if (nextUserId == 1) {\n        if (parentId != 0 || position != 0) {\n          revert UserLib.FirstUserMustBeRoot();\n        }\n      } else {\n        // Check if position is already taken\n        if (positionTaken[parentId][position]) {\n          revert UserLib.PositionAlreadyTaken();\n        }\n\n        if (users[parentId].migrated) {\n          uint256 migratedParentBv = users[parentId].bv -\n            users[parentId].bvOnBridgeTime;\n          if (migratedParentBv < 100 ether) {\n            if (position != 0 && position != 3) {\n              revert UserLib.ParentInsufficientBVForPosition(\n                position,\n                users[parentId].bv\n              );\n            }\n          } else if (migratedParentBv < 200 ether) {\n            if (position != 0 && position != 1 && position != 3) {\n              revert UserLib.ParentInsufficientBVForPosition(\n                position,\n                users[parentId].bv\n              );\n            }\n          }\n        } else {\n          uint256 parentBv = users[parentId].bv;\n          if (parentBv < 200 ether) {\n            // Can only refer to positions 0 and 3\n            if (position != 0 && position != 3) {\n              revert UserLib.ParentInsufficientBVForPosition(\n                position,\n                parentBv\n              );\n            }\n          } else if (parentBv < 300 ether) {\n            // Can refer to positions 0, 1, and 3\n            if (position != 0 && position != 1 && position != 3) {\n              revert UserLib.ParentInsufficientBVForPosition(\n                position,\n                parentBv\n              );\n            }\n          }\n        }\n        // If parentBv >= 300 ether, all positions (0, 1, 2, 3) are allowed\n      }\n\n      // Create the user\n      userId = nextUserId++;\n      addressToUserId[userAddr] = userId;\n\n      UserLib.User storage newUser = users[userId];\n      newUser.parentId = parentId;\n      newUser.userAddress = userAddr;\n      newUser.position = position;\n      newUser.lastCalculatedOrder = lastOrderId;\n      newUser.bv = 0;\n      newUser.withdrawableCommission = 0;\n      newUser.createdAt = block.timestamp;\n      newUser.active = true;\n\n      // Set path based on parent\n      if (parentId != 0) {\n        // Copy parent's path and append new position\n        UserLib.User storage parent = users[parentId];\n        for (uint256 i = 0; i < parent.path.length; i++) {\n          newUser.path.push(parent.path[i]);\n        }\n        _appendToPath(newUser.path, position);\n\n        // Mark position as taken\n        positionTaken[parentId][position] = true;\n      }\n\n      emit UserLib.UserRegistered(userId, parentId, position, userAddr);\n    }\n\n    return userId;\n  }\n\n  /**\n   * @notice Changes the caller's EOA address to a new address\n   * @dev The user ID remains the same, only the address mapping changes.\n   *      All tree relationships and commission data are preserved.\n   * @param newAddress The new EOA address to associate with the caller's user ID\n   */\n  function requestChangeAddress(\n    address oldAddress,\n    address newAddress\n  ) public {\n    // Get the caller's current user ID\n    uint256 currentUserId = addressToUserId[oldAddress];\n    if (currentUserId == 0) {\n      revert UserLib.UserNotRegistered();\n    }\n\n    require(\n      newAddress != oldAddress,\n      \"Old and new address cannot be the same.\"\n    );\n\n    changeAddressRequests[currentUserId] = newAddress;\n\n    emit UserLib.AddressChangeRequested(currentUserId, oldAddress, newAddress);\n  }\n\n  function approveChangeAddress(address sender, uint256 userId) public {\n    uint256 parentId = users[userId].parentId;\n    uint256 senderId = addressToUserId[sender];\n    require(\n      parentId == senderId,\n      \"Only direct parent of the user can approve changing address.\"\n    );\n\n    address newAddress = changeAddressRequests[userId];\n    require(\n      newAddress != address(0),\n      \"Provided user id hasn't requested for address change.\"\n    );\n    // Check if the new address is already registered\n    if (addressToUserId[newAddress] != 0) {\n      revert UserLib.AddressAlreadyRegistered();\n    }\n\n    // Store old address for event\n    address oldAddress = users[userId].userAddress;\n\n    users[userId].userAddress = newAddress;\n\n    // Update the address mappings\n    addressToUserId[oldAddress] = 0; // Remove old address mapping\n    addressToUserId[newAddress] = userId; // Set new address mapping\n\n    changeAddressRequests[userId] = address(0);\n\n    emit UserLib.AddressChanged(userId, oldAddress, newAddress);\n  }\n\n  /**\n   * @notice Checks if candidateId is in the subtree of rootId\n   * @dev Returns position of direct child through which candidate is reachable.\n   *      Uses efficient prefix matching: compares full bytes32 elements first,\n   *      then byte-by-byte only for the last partial element. This optimization\n   *      significantly reduces gas costs for deep tree structures.\n   * @param rootId The root user ID to check against\n   * @param candidateId The candidate user ID to test\n   * @return inSubTree True if candidate is in root's subtree\n   * @return position Direct child position (0-3) or SAME_NODE_SENTINEL if candidate == root\n   */\n  function _isSubTree(\n    uint256 rootId,\n    uint256 candidateId\n  ) internal view returns (bool inSubTree, uint8 position) {\n    if (!users[rootId].active || !users[candidateId].active) {\n      return (false, 0);\n    }\n\n    if (rootId == candidateId) {\n      return (true, SAME_NODE_SENTINEL);\n    }\n\n    UserLib.User storage root = users[rootId];\n    UserLib.User storage candidate = users[candidateId];\n\n    uint256 rootPathLength = _getPathLength(root.path);\n    uint256 candidatePathLength = _getPathLength(candidate.path);\n\n    // Candidate must be deeper than root to be in subtree\n    if (candidatePathLength <= rootPathLength) {\n      return (false, 0);\n    }\n\n    // Check if root's path is a prefix of candidate's path\n    // Optimization: Compare full bytes32 elements first, then byte-by-byte for the last partial element\n\n    uint256 rootFullBytes32Count = rootPathLength / 32;\n    uint256 rootRemainingBytes = rootPathLength % 32;\n\n    // Compare full bytes32 elements (much more efficient)\n    for (uint256 i = 0; i < rootFullBytes32Count; i++) {\n      if (root.path[i] != candidate.path[i]) {\n        return (false, 0);\n      }\n    }\n\n    // Compare remaining bytes in the last partial bytes32 element (if any)\n    if (rootRemainingBytes > 0) {\n      bytes32 rootLastElement = root.path[rootFullBytes32Count];\n      bytes32 candidateLastElement = candidate.path[rootFullBytes32Count];\n\n      for (uint256 j = 0; j < rootRemainingBytes; j++) {\n        if (uint8(rootLastElement[j]) != uint8(candidateLastElement[j])) {\n          return (false, 0);\n        }\n      }\n    }\n\n    // If prefix matches, return the direct child position\n    uint8 directChildPos = _getPathByte(candidate.path, rootPathLength);\n    return (true, directChildPos - 1);\n  }\n\n  /**\n   * @notice Internal function to append a position to a path array\n   * @dev Writes into the first free byte of the last bytes32, or appends new bytes32 if full\n   *      Bytes are packed left-to-right (MSB to LSB) so first position goes in byte 0\n   * @param path Storage reference to the path array\n   * @param pos Position to append (0-3)\n   */\n  function _appendToPath(bytes32[] storage path, uint8 pos) internal {\n    require(pos <= 3, \"Invalid position\");\n\n    // If path is empty or last bytes32 is full, add new bytes32\n    if (path.length == 0 || _getPathLength(path) % 32 == 0) {\n      // Put position in leftmost byte (byte 0) for new bytes32\n      path.push(bytes32(uint256(pos + 1)) << (8 * 31));\n    } else {\n      // Find the last bytes32 and append to it\n      uint256 lastIndex = path.length - 1;\n      uint256 positionInBytes32 = _getPathLength(path) % 32;\n\n      // Shift position to correct byte position and OR with existing data\n      bytes32 currentValue = path[lastIndex];\n      bytes32 newByte = bytes32(uint256(pos + 1)) <<\n        (8 * (31 - positionInBytes32));\n      path[lastIndex] = currentValue | newByte;\n    }\n  }\n\n  function _addUserBv(\n    uint256 userId,\n    uint256 weekNumber,\n    uint256 amount\n  ) internal onlyRegistered(userId) {\n    users[userId].bv += amount;\n    userWeeklyBv[userId][weekNumber] += amount;\n  }\n\n  function _getUserPairByIndex(\n    uint256 userId,\n    uint8 pair\n  ) internal view onlyRegistered(userId) returns (uint256, uint256) {\n    UserLib.User storage user = users[userId];\n    // Get the appropriate BV pair\n    if (pair == 0) {\n      // Pair 0: childrenBv[0] vs childrenBv[1]\n      return (user.childrenBv[0], user.childrenBv[1]);\n    } else if (pair == 1) {\n      // Pair 1: childrenBv[2] vs childrenBv[3]\n      return (user.childrenBv[2], user.childrenBv[3]);\n    } else {\n      // Pair 2: normalNodesBv[0] vs normalNodesBv[1]\n      return (user.normalNodesBv[0], user.normalNodesBv[1]);\n    }\n  }\n\n  function _setUserPairByIndex(\n    uint256 userId,\n    uint256 leftBv,\n    uint256 rightBv,\n    uint8 pair\n  ) internal onlyRegistered(userId) {\n    UserLib.User storage user = users[userId];\n\n    if (pair == 0) {\n      user.childrenBv[0] = leftBv;\n      user.childrenBv[1] = rightBv;\n    } else if (pair == 1) {\n      user.childrenBv[2] = leftBv;\n      user.childrenBv[3] = rightBv;\n    } else {\n      user.normalNodesBv[0] = leftBv;\n      user.normalNodesBv[1] = rightBv;\n    }\n  }\n\n  function _getUserById(\n    uint256 userId\n  ) internal view onlyRegistered(userId) returns (UserLib.User storage) {\n    UserLib.User storage user = users[userId];\n\n    return user;\n  }\n\n  function getUserById(uint256 userId) public view returns (UserLib.User memory) {\n    return _getUserById(userId);\n  }\n\n  function getUserIdByAddress(\n    address userAddress\n  ) public view returns (uint256) {\n    return addressToUserId[userAddress];\n  }\n\n  function _userExistsByAddress(\n    address userAddress\n  ) internal view returns (bool) {\n    return addressToUserId[userAddress] != 0;\n  }\n\n  function _getUserByAddress(\n    address userAddress\n  ) internal view returns (UserLib.User storage) {\n    uint256 userId = addressToUserId[userAddress];\n    if (userId == 0) {\n      revert UserLib.UserNotRegistered();\n    }\n\n    return users[userId];\n  }\n\n  function _getUserDailySteps(\n    uint256 userId,\n    uint256 dayNumber,\n    uint8 pair\n  ) internal view returns (uint8) {\n    return userDailySteps[userId][dayNumber][pair];\n  }\n\n  function _getUserWeeklyBv(\n    uint256 userId,\n    uint256 weekNumber\n  ) internal view returns (uint256) {\n    return userWeeklyBv[userId][weekNumber];\n  }\n\n  function _setUserDailySteps(\n    uint256 userId,\n    uint256 dayNumber,\n    uint8 pair,\n    uint8 value\n  ) internal {\n    userDailySteps[userId][dayNumber][pair] = value;\n  }\n}\n"
      }
    }
  }
}